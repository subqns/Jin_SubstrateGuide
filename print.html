<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Substrate Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">README</a></li><li class="chapter-item expanded "><a href="substrate_1.html"><strong aria-hidden="true">1.</strong> 环境配置与编译</a></li><li class="chapter-item expanded "><a href="substrate_2.html"><strong aria-hidden="true">2.</strong> 运行与调试</a></li><li class="chapter-item expanded "><a href="substrate_3.html"><strong aria-hidden="true">3.</strong> 具备状态的链</a></li><li class="chapter-item expanded "><a href="substrate_4.html"><strong aria-hidden="true">4.</strong> 项目结构</a></li><li class="chapter-item expanded "><a href="substrate_5.html"><strong aria-hidden="true">5.</strong> 区块头</a></li><li class="chapter-item expanded "><a href="substrate_6.html"><strong aria-hidden="true">6.</strong> 交易体</a></li><li class="chapter-item expanded "><a href="substrate_7.html"><strong aria-hidden="true">7.</strong> Substrate的模型设计</a></li><li class="chapter-item expanded "><a href="substrate_8.html"><strong aria-hidden="true">8.</strong> Runtime概要</a></li><li class="chapter-item expanded "><a href="substrate_9.html"><strong aria-hidden="true">9.</strong> Runtime的wasm与native</a></li><li class="chapter-item expanded "><a href="substrate_10.html"><strong aria-hidden="true">10.</strong> Runtime的构成</a></li><li class="chapter-item expanded "><a href="substrate_11.html"><strong aria-hidden="true">11.</strong> 学习Runtime必备的技能</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Substrate Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="substrateguide"><a class="header" href="#substrateguide">SubstrateGuide</a></h1>
<p>Substrate 入门系列文章，发于笔者知乎专栏 <a href="https://zhuanlan.zhihu.com/c_74315572">《链块与分散的数据》</a>，主要用于介绍<a href="https://github.com/paritytech/substrate">Substrate</a> 的一些基础入门，强调介绍Substrate的设计与使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---环境配置与编译---一"><a class="header" href="#substrate-入门---环境配置与编译---一">Substrate 入门 - 环境配置与编译-  （一）</a></h1>
<p>substrate目前已经趋近成熟，因此可以比较系统的对Substrate进行介绍。</p>
<p>本文首先介绍substrate的依赖与编译过程，以此管中窥豹了解substrate的概况。</p>
<p>因笔者的开发环境是ubuntu/deepin/debain，因此后文命令皆基于这个环境下。</p>
<h2 id="一-前言"><a class="header" href="#一-前言">一 前言</a></h2>
<p>截止目前为止（2019年12月1日，提交<code>33476f08b3400a07fd7c69cd5bf4ad8f47f11373</code>），substrate的README已经出现比较大的改动，所有文档集中到了substrate的官方文档中 <a href="https://substrate.dev/docs/en/getting-started/">substrate.dev</a>。而本身对于环境的配置（linux/mac os）过程已经迁移到了脚本<code>https://getsubstrate.io</code>中，即该<a href="https://substrate.dev/docs/en/getting-started/installing-substrate#unix-based-operating-systems">链接</a>。在这个链接中的介绍为：</p>
<pre><code class="language-bash">curl https://getsubstrate.io -sSf | bash -s -- --fast
</code></pre>
<p>但是现在的这种配置方式已经把很多细节隐藏了，且后续执行的命令<code>--fast</code>实际上把substrate下载到了一个temp目录中进行编译并安装到了cargo命令目录下，实际上并不方便想要探究substrate的开发者，因此本文将跳开脚本，把本身配置环境与编译的过程重新介绍。</p>
<h2 id="二-环境配置"><a class="header" href="#二-环境配置">二 环境配置</a></h2>
<p>以下过程实际和脚本 <code>https://getsubstrate.io/index.html</code>相同，因此若有疑问可参考脚本本身的内容。</p>
<p>环境配置分为两个部分：</p>
<ol>
<li>依赖库</li>
<li>rust编译链</li>
</ol>
<p>其他linux发行版，mac os可以对应进行参考</p>
<h3 id="1-依赖库"><a class="header" href="#1-依赖库">1. 依赖库</a></h3>
<pre><code class="language-bash"> apt install -y cmake pkg-config libssl-dev git gcc build-essential git clang libclang-dev
</code></pre>
<p>在依赖库中大部分都是正常的编译工具，这里重点介绍以下<code>libssl-dev</code>。这个库实际上就是提供ssl的支持，在substrate中用于 Libp2p 与 websocket 这两个库的编译依赖，提供ssl保护。因此对应与其他发行版（如centos，redhat等）就是提供类似<code>openssl</code>的编译依赖。</p>
<p>在同一发行版的不同版本上编译后需要在另一个版本上运行时（例如在ubuntu 17.04上编译，把执行文件拷贝到ubuntu16.04上），尤其需要注意这个库（ssl）的动态链接依赖。例如在ubuntu 17.04默认的openssl库使用的是 <code>openssl 1.1</code> 以上的版本，而 ubuntu 16.04 使用的时 openssl1.0 版本。因此把ubuntu17.04编译的版本放到16.04上会出现动态链接库不匹配的问题。</p>
<p>若需要在ubuntu 17.04及以上版本编译出能在16.04版本上运行的执行文件，可以在编译环境下装好执行环境对应的openssl版本，然后使用</p>
<pre><code class="language-bash">export OPENSSL_LIB_DIR=&quot;&lt;you path&gt;&quot;
export OPENSSL_INCLUDE_DIR=&quot;&lt;you path&gt;&quot;
</code></pre>
<p>导出这两个环境变量，再进行编译。</p>
<p>ps：在脚本中对于arch系指定的openssl版本时 1.0 的，因为笔者不用arch系的linux，尚不可知为何parity团队要指定这个版本。若需要探究的话可参考到 rust-libp2p的相应需求。</p>
<h3 id="rust-编译链"><a class="header" href="#rust-编译链">rust 编译链</a></h3>
<p>rust的安装简单得多，首先按照rust官网装好rust环境，确保有<code>rustup</code>和<code>cargo</code>命令后：</p>
<pre><code class="language-bash">rustup update nightly  # 安装 nightly 编译链
rustup target add wasm32-unknown-unknown --toolchain nightly  # 对 nightly 编译链添加 wasm 编译target
</code></pre>
<p>这里说明：</p>
<p>实际上自rust stable 1.38之后 wasm 的这个target就已经可以提供给stable了，但是由于substrate改变了其编译wasm的方式，是在substrate的代码中指定了使用nightly编译wasm，因此这里如果只给stable添加<code>wasm32-unknown-unknown</code>是没有用的，必须先提供nightly编译链，再对nightly添加wasm的target。</p>
<p>在该版本的substrate中已经不需要在添加<code>wasm-gc</code>做wasm的压缩。（windows的还是看到了这个命令，笔者怀疑是substrate的文档还没有改）</p>
<h2 id="三-编译"><a class="header" href="#三-编译">三 编译</a></h2>
<p>首先讲substrate项目拉下来</p>
<pre><code class="language-bash">git clone https://github.com/paritytech/substrate.git
</code></pre>
<p>参照之前笔者的文章，这里建议导出一个环境变量：</p>
<pre><code class="language-bash">export WASM_BUILD_TYPE=release
</code></pre>
<p>在这个环境变量下编译出的wasm才是以release模式编译，否则可能影响出块。</p>
<p>因此进入substrate目录后</p>
<pre><code class="language-bash">cd substrate
</code></pre>
<p>编译可以采用</p>
<pre><code class="language-bash">cargo build
# 若刚才没有导出 WASM_BUILD_TYPE 可以在这里执行以下命令强制设定
#  WASM_BUILD_TYPE=release cargo build
</code></pre>
<p>这里首先说明，在cargo下：</p>
<pre><code class="language-bash">cargo run -- &lt;参数&gt;  # 注意这里有两个横杆 --
# 等于
cargo build &amp;&amp; ./target/debug/&lt;项目执行文件&gt; &lt;参数&gt;
# 而 release编译
cargo run --release -- &lt;参数&gt;
# 等于
cargo build --release &amp;&amp; ./target/release/&lt;执行文件&gt; &lt;参数&gt;
</code></pre>
<p>对于substrate而言，执行</p>
<pre><code class="language-bash">cargo run -- --dev
</code></pre>
<p>等于</p>
<pre><code class="language-bash">cargo build &amp;&amp; ./target/debug/substrate --dev
</code></pre>
<p>由于substrate项目编译后（<code>cargo build</code>）当前会在target目录下生成多个可执行文件，因此请依据自己当前的需求执行。</p>
<h3 id="注意的点"><a class="header" href="#注意的点">注意的点：</a></h3>
<ol>
<li>
<p>wasm是否以release编译</p>
<p>查看 <code>target/&lt;debug/release&gt;/wbuild/node-runtime/node_runtime.compact.wasm</code>的大小，若其大小是1.3M左右，可确定是以release编译，若是8M以上，则一定是以debug编译，此时建议设置好相应环境变量重新编译。</p>
</li>
<li>
<p>编译后的执行文件</p>
<p>编译后产生的执行文件有4个</p>
<ul>
<li>substrate  # 即 substrate的node项目执行文件，源码位于<code>bin/node</code>，研究substrate的基础入口，cargo run 执行的文件即为该文件</li>
<li>node-rpc-client # 与substrate node进行交互的rpc执行文件，源码位于<code>bin/node/rpc-client</code>下，注意这个和node交互，不是与node-template交互</li>
<li>node-template  # 精简版的node，源码位于<code>bin/node-template</code>，与node相比去除了大部分runtime模块，可最为最精简链运行</li>
<li>subkey # 用于生成一些公私钥的工具，源码位于<code>bin/substrate</code></li>
</ul>
</li>
</ol>
<p>对于substrate的研究，只需要关心node项目即可，不擅长js的，可用辅助使用node-rpc-client用来发交易。</p>
<h2 id="其他"><a class="header" href="#其他">其他</a></h2>
<p>在substrate的官方脚本中，后续操作还安装了<code>https://github.com/paritytech/substrate-up</code>这个项目，该项目是用来生成依托于substrate框架的链的一个模板生成工具。由于substrate更新很频繁，这个工具早已更不上变化，因此不建议安装。</p>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>由于substrate官方的安装脚本隐藏了很多细节，且没给予用户一些选择的权利，因此本文不建议使用脚本安装，而是梳理了当前substrate的环境配置与编译，并解释了各个步骤的含义。因此用户可根据本文的解释结合自己的环境情况进行substrate的编译环境配置。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---运行与调试--二"><a class="header" href="#substrate-入门---运行与调试--二">Substrate 入门 - 运行与调试 -（二）</a></h1>
<p>上一篇文章中介绍了substrate的环境配置与编译，本文描述如何运行节点并对其进行调试。</p>
<p>当能够对一个程序进行调试时，就相当于掌握了如何探究其原理的工具，剩下的只需要毅力和时间了。因此掌握调试方法是很重要的。</p>
<h2 id="运行节点"><a class="header" href="#运行节点">运行节点</a></h2>
<p>对于学习Substrate而言，一开始只需要能够单节点运行即可。接上一章，能够使用<code>cargo build</code>以后，执行</p>
<pre><code class="language-bash">cargo run --bin substrate -- --help
# 等价于 ./target/debug/substate -- --help
</code></pre>
<p>请大致浏览一下<code>help</code>信息，其中很多启动指令是很重要的。这里先大致看过来有一个印象。</p>
<p>ps：注意这里指定了<code>--bin substrate</code>，因为Substrate编译后会有多个执行文件，但是我们目前只需要了解substrate即可。</p>
<h3 id="运行单节点"><a class="header" href="#运行单节点">运行单节点</a></h3>
<p>这里推荐运行单节点的方式为：</p>
<pre><code class="language-bash">cargo run --bin substrate  -- --dev -d .sub --execution=NativeElseWasm
</code></pre>
<p>其中</p>
<ul>
<li><code>--dev</code>是运行单节点的命令，具体内容请看help</li>
<li><code>-d</code> 是<code>--base-path</code>的简写，用于指定数据跟目录的，请注意若不指定这个目录，会默认把数据放在用户的目录下，linux系的操作系统将会放于<code>~/.local/share/substrate</code>目录下，mac os 位于<code>~/Library/Application Support/substrate</code> 与windows 位于<code>%APPDATA%\substrate</code> （例如<code>c:\User\&lt;you account&gt;\AppData\Roaming\substrate</code>）下。具体原理请参见这个库<a href="https://docs.rs/app_dirs/1.2.1/app_dirs/">app-dirs</a></li>
<li><code>--execution</code>是节点采用的执行方式，这里采用NativeElseWasm，尽量以Native的方式运行。Native与Wasm的关系请参见笔者之前的文章，后续也将专门花一篇文章讲解。这里为了调试请以Native的方式运行。</li>
</ul>
<p>运行后，会出现以下日志：</p>
<pre><code class="language-bash">2019-12-02 21:34:38 Running in --dev mode, RPC CORS has been disabled.
2019-12-02 21:34:38 Substrate Node
2019-12-02 21:34:38   version 2.0.0-33476f08b-x86_64-linux-gnu
2019-12-02 21:34:38   by Parity Technologies, 2017-2019
2019-12-02 21:34:38 Chain specification: Development
2019-12-02 21:34:38 Node name: squealing-volcano-7235
2019-12-02 21:34:38 Roles: AUTHORITY
2019-12-02 21:34:41 Initializing Genesis block/state (state: 0xcfa1…1f33, header-hash: 0x7aed…4a2a)
2019-12-02 21:34:41 Loading GRANDPA authority set from genesis on what appears to be first startup.
2019-12-02 21:34:42 Loaded block-time = BabeConfiguration { slot_duration: 3000, epoch_length: 200, c: (1, 4), genesis_authorities: [(Public(d43593c715fdd31c61141abd04a99fd6822c8558854ccde39a5684e7a56da27d (5GrwvaEF...)), 1)], randomness: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], secondary_slots: true } milliseconds from genesis on first-launch
2019-12-02 21:34:42 Creating empty BABE epoch changes on what appears to be first startup.
2019-12-02 21:34:43 Highest known block at #0
2019-12-02 21:34:43 Using default protocol ID &quot;sup&quot; because none is configured in the chain specs
2019-12-02 21:34:43 Local node identity is: QmPx8ErgDnK2yzcNzWWZfcpA5jG5BiqHnYhxj8uP78R1wP
2019-12-02 21:34:43 Starting BABE Authorship worker
2019-12-02 21:34:43 Grafana data source server started at 127.0.0.1:9955
2019-12-02 21:34:45 Starting consensus session on top of parent 0x7aed7beac8e270a7c1b94c388bf2dd458a583793eb1cf6cbdaac5c2b53bc4a2a
2019-12-02 21:34:47 Prepared block for proposing at 1 [hash: 0x9ef353fac64fb410da9dcddb413bc32605be0bddc37600f4308a8fe16c67cd48; parent_hash: 0x7aed…4a2a; extrinsics: [0xdd07…0f07]]
2019-12-02 21:34:47 Pre-sealed block for proposal at 1. Hash now 0x7092bd4729d239cc50ddea5ebca686956747d429ebc5fdd04437eb3d1b2c5144, previously 0x9ef353fac64fb410da9dcddb413bc32605be0bddc37600f4308a8fe16c67cd48.
2019-12-02 21:34:47 New epoch 0 launching at block 0x7092…5144 (block slot 525097895 &gt;= start slot 525097895).
2019-12-02 21:34:47 Next epoch starts at slot 525098095
2019-12-02 21:34:47 Imported #1 (0x7092…5144)
2019-12-02 21:34:48 Idle (0 peers), best: #1 (0x7092…5144), finalized #0 (0x7aed…4a2a), ⬇ 0 ⬆ 0
2019-12-02 21:34:48 Starting consensus session on top of parent 0x7092bd4729d239cc50ddea5ebca686956747d429ebc5fdd04437eb3d1b2c5144
2019-12-02 21:34:48 Prepared block for proposing at 2 [hash: 0x401eaa5aad96fa270be3e8441e8f9b260496bc45594a314975be0a0e209bcd0c; parent_hash: 0x7092…5144; extrinsics: [0x147a…25aa]]
2019-12-02 21:34:48 Pre-sealed block for proposal at 2. Hash now 0x0c173a3e655a50bbc93998d15ab8adedac76bc751e9d8eea173132f51b8731eb, previously 0x401eaa5aad96fa270be3e8441e8f9b260496bc45594a314975be0a0e209bcd0c.
2019-12-02 21:34:48 Imported #2 (0x0c17…31eb)
</code></pre>
<p>按<code>CTRL+C</code>可以中断进程退出。</p>
<p>请注意，只有当日志中出现以下日志时</p>
<pre><code class="language-bash">Starting consensus   # 共识准备
 Pre-sealed block  for proposing at &lt;块高&gt;, 区块hash, 父区块hash, 该区块中的交易hash # 预打包区块，其中的交易
 Imported #&lt;块高&gt;  # 区块落盘，一定要看到这一条才表示区块出块流程正常进行
</code></pre>
<p>才算区块正常出块。</p>
<p>其中，若编译时使用产生的WASM文件是debug（参见上一篇文章）时，或者当前的电脑cpu性能过于弱时，可能会产生</p>
<pre><code class="language-bash">Discarding proposal for slot {}; block production took too long
</code></pre>
<p>的日志。</p>
<p>请注意如果确定<strong>只是</strong>因为当前环境的cpu性能过弱时，可以采取修改出块时间的方式先暂时回避这个问题</p>
<p>文件：<code>bin/node/runtime/src/constants.rs</code> 中，修改</p>
<pre><code class="language-bash"># 请详细参见附近的注释，该常量用于控制出块时间间隔，因此当 took too long 的时候把出块时间加长
pub const MILLISECS_PER_BLOCK: Moment = 3000;
</code></pre>
<p>这个常量，将其修改得大一些，使得出块时间变长，这样第一次加载环境的时候就不会<code>took too long</code>导致无法出块了。</p>
<p><strong>请注意修改了这个常量后一定要重新编译，对于初学者而言若还搞不清楚其他情况时，请直接将之前生成的数据目录（<code>-d</code>指定的目录）直接删除，再重新运行节点</strong></p>
<h2 id="调试"><a class="header" href="#调试">调试</a></h2>
<p>笔者使用Clion进行开发，因此这里只介绍clion调试的方式，使用gdb的开发者直接操作即可。</p>
<p>首先在clion中先设置编译配置：</p>
<p><img src="imgs/s2_1.png" alt="s2_1" /></p>
<p>然后点击左上角的“+”，选择<code>cargo command</code></p>
<p><img src="imgs/s2_2.png" alt="s2_2" /></p>
<p>然后在以下位置配置相应的命令：</p>
<p><img src="imgs/s2_3.png" alt="s2_3" /></p>
<ul>
<li><code>Command</code>的部分命令和之前启动命令一致，只需要把cargo去掉即可，因此也就是说这里的Command就是平时的启动命令，可以根据自己本身的命令进行配置，注意如果在下断点到runtime内部的时候，execution一定是要Native或者NativeElseWasm</li>
<li><code>Environment variables</code> 环境变量部分请配置上<code>WASM_BUILD_TYPE</code></li>
<li><code>Working directory</code>配置上substrate的根目录</li>
</ul>
<p>以上配置好了点Ok确定后，原来添加配置的部分会默认显示刚刚配置好的这个启动命令。</p>
<p>接下来下断点，对于初学者，下断点最好的部分位于每个块都会执行的一个部分：设置时间</p>
<p>因此我们把断点下在<code>frame/timestamp/src/lib.rs</code> 第 145行：</p>
<p><img src="imgs/s2_4.png" alt="s2_4" /></p>
<p>该部分即时每个块都会设置出块时间的地方。使用gdb的开发者同理，找到这个文件的这个地方下断点即可。</p>
<p>设置好断点后，即可点击右上角像虫子一样的按钮开始运行调试（建议先清空数据目录）</p>
<p><img src="imgs/s2_5.png" alt="s2_5" /></p>
<p>启动调试后，如果正常一会之后将会在断点处停下：</p>
<p><img src="imgs/s2_6.png" alt="s2_6" /></p>
<p>请注意左下方的调用栈，这即是最能帮助开发者了解代码运作过程的信息源。从调用栈中可以很快速了解很多信息。</p>
<p>而领边的<code>Variables</code>提供很多当前这个栈中数据的信息，对于debug相当有用。</p>
<h2 id="日志"><a class="header" href="#日志">日志</a></h2>
<p>substrate使用了rust默认的日志接口，因此在substrate中看得到这样的日志：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!(target: &quot;babe&quot;,   &quot;Creating empty BABE epoch changes on what appears to be first startup.&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>请注意<code>info!</code>的第一个参数是<code>target:</code>，而不是日志内容。这个是用于日志标签分类打印。由于substrate使用的日志记录器是<code>env_logger</code>，并且substrate编写了一些运行时解析的代码</p>
<p>client/cli/src/ib.rs:L965</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_logger(pattern: &amp;str) {
	use ansi_term::Colour;
    ...
   if let Ok(lvl) = std::env::var(&quot;RUST_LOG&quot;) {
		builder.parse_filters(&amp;lvl);  // 这里，设置了日志filter
	}
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>因此启动时可以通过这个环境变量设置日志的过滤内容，如上面那个日志的target是&quot;babe&quot;，则启动时可以设置：</p>
<pre><code class="language-bash">RUST_LOG=warn;babe=debug cargo run --bin substrate -- --dev -d .sub --execution-NativeElseWasm
# 或者
RUST_LOG=warn;babe=debug ./target/debug/substrate -- --dev -d .sub --execution-NativeElseWasm
</code></pre>
<p>同理，在clion的启动配置的<code>Environment variables</code> 中也可以配置这个环境变量。这样启动的节点就会</p>
<ul>
<li>其他日志只打印 warning 级别的日志</li>
<li>对于 target 是 babe 的日志，会打印 debug 级别的日志</li>
</ul>
<p>因此通过这种filter的形式，可以控制日志的打印，这样对调试节点及学习substrate有相当大的好处。</p>
<h2 id="总结-1"><a class="header" href="#总结-1">总结</a></h2>
<p>本文主要说明了如何启动一个substrate节点，及启动节点后如何对节点进行调试，以及如何对节点中的日志进行filter以便于调试。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---具备状态的链--三"><a class="header" href="#substrate-入门---具备状态的链--三">Substrate 入门 - 具备状态的链 -（三）</a></h1>
<p>本文首先介绍substrate的模型基础。在能理解了“链的状态”和“交易”关系后，在此模型下才可深入Substrate的设计当中。</p>
<h2 id="结论"><a class="header" href="#结论">结论</a></h2>
<p>首先先表述结论：Substrate的数据模型<strong>与以太坊一致</strong>，是<strong>基于MPT</strong>（Merkle Patricia Tree）的“全历史世界状态”模型。</p>
<p>这里展开讲一点：</p>
<p>当前区块链用于对业务进行建模的模型主要有两类：</p>
<ol>
<li>UTXO 模型，即比特币及其分支的模型</li>
<li>状态模型，即以以太坊为代表，包含eos及其他区块链等以记录状态为主的模型</li>
</ol>
<p>因为当前主流描述业务的方式主要还是以<strong>状态迁移</strong>的模型去建模业务，因此状态模型的区块链能更容易支持更广泛的场景。</p>
<p>本系列只介绍状态模型，UTXO模型请参照笔者之前关于比特币的相关文章。</p>
<h2 id="状态区块链"><a class="header" href="#状态区块链">状态区块链</a></h2>
<p>对于没有接触过状态区块链的开发者而言，首先请记住以下一些基础概念：</p>
<ol>
<li>当前状态是从genesis（即第0块，初始状态）开始，通过交易或其他方式产生了状态变更，不断累计出来的。</li>
<li><strong>状态并不是储存块中，而是节点自身独立维护的。</strong></li>
<li>块中记录的是“状态迁移”的方式</li>
</ol>
<p><img src="imgs/s3_1.png" alt="s3_1" /></p>
<p>如上图所示即是一个链的状态变化的过程。</p>
<p>比如在genesis的时候，状态为<code>A:1 B:2</code> 而经过块1的过程后，通过交易（tx）或其他因素，将A的状态修改成了2，因此在块1下的“世界状态”就变为了<code>A:2 B:2</code>。块2以此类推。</p>
<p>因此实际上块中并不是记录当前的状态，而是节点自己本地维护了一个“世界状态”。这个状态就是存在本地的数据库中。而块中保存的时“状态迁移”，“状态迁移”就是交易（或其他因素），节点同步/执行了一个区块后，通过区块中含有的迁移状态的方式（即是在执行这个区块），修改自己的本地状态，从而当一个块执行完毕后，本地当前的状态即为这个块下的状态。</p>
<p>而对于当前状态模型的链而言，一般情况下会具备如下的特性：</p>
<ol>
<li>最新块（最高块）下的状态即为当前的状态，在这个状态下可以<strong>获取当前所有对象的状态</strong>。</li>
<li>块中含有对这个块下的状态的证明（即状态的统一性经过了节点间共识）</li>
<li>可以通过任意一个历史的区块，取到在这个区块下的状态（如当前最高块已经是2，而通过1块中的相关信息可以取到<code>A:2</code>而不是最高块下的<code>A:4</code>）</li>
</ol>
<p>这3个条件中只有1是必须满足的，往后越达成一个条件，需要付出的代价就要更多。若能满足这3个条件，即是“全历史世界状态”。</p>
<p>当然这里的词“全历史世界状态”是笔者自己造的，因为在以太坊的那个时代，还只有“世界状态”的概念。而实际上以太坊的“世界状态”是将每一个块的那个时刻的状态都做了“快照”，可以恢复到任意块的时候下的状态，也就是将全部的“状态变化历史”都保存下来的方式，因此笔者对这种模型命名为“全历史状态”。但是显然，这种方式将会将所有过去的历史都存下来，因此会造成数据量十分庞大。因此这种方式是状态区块链的一个极端。</p>
<p>而牺牲第3个条件，保留状态证明与只保留最新状态是一种权衡。而第3点就不再交由链来维护，而交给第三方的附属设施维护，如中心化数据库，区块链浏览器等等。</p>
<p>若连第2个条件也不用，则是状态模型的另一种极端，这种极端一定情况下牺牲了共识状态安全性。这种方式带来的好处是实现上比较简单。这即是eos的模型。</p>
<h2 id="mpt-实现的世界状态"><a class="header" href="#mpt-实现的世界状态">MPT 实现的世界状态</a></h2>
<p>由于Substrate采用了和以太坊一样的模型，因此满足上述的3个条件。在Substrate中MPT简称为<code>trie</code>。</p>
<p>对于MPT实现的原理这里不进行详细描述。简单来说MPT的实现和<code>git</code>，IPFS中的IPLD模型等原理上都是一致的，用一句话描述就是：</p>
<p>使用DAG的方式，只记录每次变更后的索引（hash）。</p>
<p>如下图所示：</p>
<p><img src="imgs/s3_2.png" alt="s3_2" /></p>
<p>例如在上文提到的状态<code>A:1 B:2</code>，将A，B分别看做两个key，在MPT中key就是树的路径，而<code>1,2</code>是key对应的值，在MPT中就是叶子节点。因此<code>A:1 B:2</code> 变更到<code>A:2 B:2</code>的这个过程中，对应到上图相当于：</p>
<ul>
<li>从 root -&gt; 2 -&gt; value2 相当于记录了 <code>A:1</code>，从root-&gt;3-&gt;value3的过程相当于记录了<code>B:2</code></li>
<li>从genesis到 block1 的过程中，A的状态发生了变化，从1变成了2</li>
<li>在MPT 中由于A的值发生了变化，因此MPT生成了一个新的叶子节点代表A的新状态，然后<strong>从叶子节点重新生成一个新的索引路径</strong>，即图中的 <code>value2' -&gt; 2'-&gt; root'</code>的过程</li>
<li>而在生成新路径的过程中，由于B的状态没有发生变化，因此在生成新的路径的过程中，直接索引了B的老路径（即图中的虚线）。</li>
<li>因此如上图所示，通过新的树根<code>root'</code> 索引到的A和B的值分别是<code>A：2</code>（即新的A的状态）与<code>B：2</code>（即老的B的状态）</li>
</ul>
<p>如以上过程所示，每一个新的树跟记录的这个树根下状态的索引，因此每一个树跟即是每一个状态的DAG的起点，通过这个起点，可以获取到所有的状态。</p>
<p>每个区块都会含有状态变更，而每次变更即是通过以上类似过程生成一个新的树根，这个根root在以太坊及Substrate中被称为状态根 <code>state_root</code>，<strong>放入每一个区块的区块头中</strong>，作为当前这个区块进行共识的<strong>状态证明</strong>。而通过以上方式也可以看出，只要从任意区块中取出状态根，那么就可以获取到这个状态根下那个时刻的所有状态的值。（对于相当同的key A，通过 root 索引出 value2，通过 root' 索引出 value2'）</p>
<p>因此，MPT这种数据结构描述的世界状态，满足上述所说的3个条件。</p>
<h2 id="另一个角度"><a class="header" href="#另一个角度">另一个角度</a></h2>
<p>抛开以上原理不谈，我们可以<strong>将trie看成一个K-V数据库</strong>，这个数据库通过给予的Key能够获取到对应的Value。只不过这个k-v数据库通过给予一个root可以索引出在这个root的那个时刻下的对应数据。</p>
<p>也就是说trie实现的链上状态就是一个带快照的k/v数据库。每一个块就是对当前数据库全部数据的快照，块的时间戳代表了那个时刻下的数据状态，通过块中的状态根可以获取那个时刻下的数据。</p>
<p>而在打包执行当前区块时使用的root即是上一个区块的root，也就是打包区块时取当前最新的状态。</p>
<p>在Substrate中对于Runtime层而言，提供的接口即是</p>
<ul>
<li>get(key) -&gt; value</li>
<li>set(key, value) / remove(key)</li>
</ul>
<p>这样的接口对于Runtime而言，可以直接将trie树看做一个key/value数据库即可，屏蔽了所有的trie树细节。</p>
<p>因此对于初学者而言，若目前还不是很容易搞清楚trie树的实现细节，那么就不用关心，只需要记住Substrate的读写数据模型是<strong>key/value数据库</strong>即可。</p>
<h2 id="总结-2"><a class="header" href="#总结-2">总结</a></h2>
<p>实际上状态模型区块链即使通过各种实现方式，能够在每个块下记录这个块当前的状态（key/value）。只不过使用mpt树实现的“全历史世界状态”是包含上文提到的3种性质的一种实现，这是一种极端，包含了证明与历史，但对应的也会带来数据的膨胀。</p>
<p>Substrate采用的是这种MPT树实现的状态区块链模型。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---项目结构--四"><a class="header" href="#substrate-入门---项目结构--四">Substrate 入门 - 项目结构 -（四）</a></h1>
<p>在开始讲解Substrate的内容之前，还需要补充一个<strong>当前</strong>Substrate的项目结构。之所以这里强调“当前”是因为Substrate从之前的结构到现在已经发生了巨大的变化，如果不重新再介绍以下，后续的文章介绍起来就会有一些麻烦。</p>
<p>笔者在一年前已经写过一个Substrate的项目结构<a href="https://zhuanlan.zhihu.com/p/56414647">《Substrate 设计总览 （二）》</a>的介绍，但是截止目前项目的结构几乎已经全部变了。因此重新进行介绍。（在看本文前最好先了解了Substrate的设计总览：<a href="https://zhuanlan.zhihu.com/p/56383616">《Substrate 设计总览》</a>）</p>
<p>本文所基于的Substrate提交为：<code>a98625501be68cc3084e666497c16b111741dded</code>，即2019年12月21日的提交。</p>
<h2 id="core-primitives--client"><a class="header" href="#core-primitives--client"><code>core</code>-&gt;<code>primitives</code> + <code>client</code></a></h2>
<p>以前的<code>core</code>目录包含了所有的链的功能模块的部分，也就是所谓的Substrate的框架主体内容。在现在的版本中，拆成了<code>primitives</code> + <code>client</code>两个部分。</p>
<p>其中：</p>
<ul>
<li><code>primitives</code>：元语，赋予了新的含义，用于<strong>定义</strong>一条链中很多<strong>基础设置</strong>的模块。实际上这个归类也是比较笼统的，但是主要还是用来定义用的，举例来说：
<ul>
<li><code>primitives/core</code>中定义了密码学类型如<code>ed25519</code>，<code>sr25519</code>等，定了<code>hash</code>，定义了<code>H160</code>，<code>H256</code>，<code>H512</code>等长度类型，</li>
<li><code>primitives/runtime</code>定义了“Runtime”中需要用到的基础类型，如区块头 <code>Header</code>，区块<code>Block</code>，交易体<code>extrinisic</code>，区块头附带的信息“digest”，“Runtime”编写过程中用到的一些基础工具，如错误处理<code>DispatchError</code>，兼容多种类型签名的<code>MultiSignature</code>，Runtime中的随机数，交易合法验证，offchain的一些类型定义等等</li>
<li><code>primitives/consensus</code>Substrate提出的新共识的核心<code>aura</code>，&quot;babe&quot;，以及“pow”的一些类型定义，注意这里只是一些定义以及对于Runtime的api接口，实现在<code>client/consensus</code>对应的模块下。</li>
<li><code>primitives/api</code>runtime的api的工具宏定义</li>
<li><code>primitives/trie</code> 对 MPT 的包装，MPT见上文介绍，实现在<code>trie-db</code>这个库中</li>
<li><code>primitives/std</code> 和 <code>primitives/io</code> 原来的<code>sr-std</code> 和<code>sr-io</code>，用于提供Runtime中的对于wasm编写的支持以及runtime访问trie的接口。</li>
<li>等等内容</li>
</ul>
</li>
</ul>
<p>而对于另一个模块<code>client</code>而言：</p>
<ul>
<li><code>client</code>是对于很多模块的<strong>功能实现</strong>以及集成功能模块组件
<ul>
<li><code>client/api</code>就是对于runtime api 调用包装的实现</li>
<li><code>client/consensus</code>是对共识模块的实现。</li>
<li><code>client/network</code>是对网络p2p的实现，底层使用Libp2p</li>
<li><code>client/state-db</code>是对每个块提交到MPT的过程的管理</li>
<li><code>client/service</code>是对许多功能模块的集成，例如网络模块，交易池，rpc等等，service相当于启动了这些模块并持有这些模块的引用</li>
<li><code>client/cli</code>是对命令行的解析并根据相应的参数配置service</li>
<li>等等... 由于本系列主要是为了介绍使用substrate，而不是讲解substrate怎么实现，所有就不必说的很细致了。</li>
</ul>
</li>
</ul>
<p>所以在今后的文章中介绍<code>primitives</code>/<code>client</code> 即代表着这些是Substrate框架内的代码，若要修改，需要进行fork</p>
<p>ps:（这是不严谨的说法，实际上也可以引用<code>primitives</code>，自己实现<code>client</code>，只所以这么说是因为<code>client</code>可以看做<code>Substrate</code>定义的基础结构的一种实现，当然可以独立进行另一种client的实现。但由于当前的client里面是一种实现，因此里面的模块都是互相关联的，很难只修改其中某个组件，如果需要沿用Substrate的实现但是需要修改其中的某些实现，那么只能fork修改了。）</p>
<h2 id="srml---frame"><a class="header" href="#srml---frame"><code>srml</code> -&gt; <code>frame</code></a></h2>
<p>参见笔者之前的《Substrate 设计总览》与《Substrate 设计总览 （二）》，应该知道了Runtime的概念，与Substrate中实现Runtime的模块srml（Substrate Runtime Module Library）。在新版中，<code>srml</code>命名为了<code>frame</code>。</p>
<p>对于<code>frame</code>而言，模块之间没有很大的迁移，基本沿袭了原来的命名与结构，只不过新增了很多的runtime module 模块。</p>
<p>如理解了这两篇文章的内容，那么应该可以理解<code>frame</code>中除了“system”之外，都是可以由开发者自由实现的，实际上使用Substrate链编写的应用链的核心部分就是开发自己的Runtime Module。编写自己的Runtime Module不会写的时候，就需要去模仿<code>frame</code>模块中这些模块的编写技巧。其中提供了很多最佳实现这类的东西。</p>
<h2 id="node--node-template--subkey--其他---bin"><a class="header" href="#node--node-template--subkey--其他---bin"><code>node</code> + <code>node-template</code> + <code>subkey</code> + 其他 -&gt; <code>bin</code></a></h2>
<p><strong>对于上文的 <code>primitive</code>，<code>client</code>或者再加上<code>frame</code>中的<code>system</code>共同构成了Substrate的框架</strong>，而对于新版本中的<code>bin</code>则是对Substrate框架的<strong>使用案例</strong>（一种实现），因此**<code>bin</code>中的内容就是Substrate的框架外**的部分。</p>
<p>在新版本中把原来的node，node-template等全部移动到了bin中，代表这些模块是可以进行“可执行文件”的入口。因此调试也好，研究数据流流转也好，都是从这个入口开始。</p>
<p>所以在今后的文章中，介绍<code>bin</code>中的代码，即代表着这是使用者可以自由进行定制的部分，可参考bin中的一些组件进行修改。而bin中的案例即是如何把runtime和service组合在一起的案例。</p>
<p>对于本系列而言，只用参考node的实现就够了，因为它的实现是最全面的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---区块头--五"><a class="header" href="#substrate-入门---区块头--五">Substrate 入门 - 区块头 -（五）</a></h1>
<p>关于“区块链”的块链结构这里就不再赘述，听过这个名词的应该都多少在心里能想到大概的样子。因此本文直接开始从Substrate的区块头结构开始讲解。</p>
<p>总体来说，substrate的卖点就是一个区块链框架，因此实际上对于区块头，交易体等一系列区块链中的基本元素而言，都是可以<strong>自行定制</strong>的，并非是固定的结构体。然而由于区块头中含有的一些证明及一些属性与区块链的运行过程（基于状态），共识（共识证明）等方面是“强耦合”的，因此一般情况下在Substrate中使用的区块头都直接使用了Substrate默认提供的，<strong>极少有需求需要对其进行更改</strong>。</p>
<h2 id="substrate核心与用户可在框架下编写的模块的分界线"><a class="header" href="#substrate核心与用户可在框架下编写的模块的分界线">substrate核心与用户可在框架下编写的模块的分界线</a></h2>
<p>参考本系列第四篇<a href="https://zhuanlan.zhihu.com/p/98684002">《Substrate 入门 - 项目结构 -（四）》</a>中的描述，应该清楚的知道，位于<code>/bin</code>目录下的代码属于框架外的，可以参考的，位于<code>primitives</code>及<code>client</code>里面的代码属于Substrate框架内的，一般情况下不改动的。</p>
<p>因此位于不同的文件夹下即是Substrate框架与用户编写代码的分界线。</p>
<h2 id="区块头"><a class="header" href="#区块头">区块头</a></h2>
<p>总所周知，在区块链的块结构中，一个块由区块头（block_header）与该区块下的交易体共同构成。</p>
<p>而<strong>共识</strong>实际上共识的就是区块头，区块头就是对这个区块信息的<strong>摘要</strong>与<strong>证明</strong>。</p>
<h2 id="substrate的区块头"><a class="header" href="#substrate的区块头">Substrate的区块头</a></h2>
<h3 id="1-框架内"><a class="header" href="#1-框架内">1. 框架内</a></h3>
<p>Substrate提供了一个Header的模板，位于<code>/primitives/runtime/src/generic/header.rs</code>文件中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Header&lt;Number: Copy + Into&lt;U256&gt; + TryFrom&lt;U256&gt;, Hash: HashT&gt; {
	/// The parent hash.
	pub parent_hash: Hash::Output,
	/// The block number.
	#[cfg_attr(feature = &quot;std&quot;, serde(
		serialize_with = &quot;serialize_number&quot;,
		deserialize_with = &quot;deserialize_number&quot;))]
	pub number: Number,
	/// The state trie merkle root
	pub state_root: Hash::Output,
	/// The merkle root of the extrinsics.
	pub extrinsics_root: Hash::Output,
	/// A chain-specific digest of data useful for light clients or referencing auxiliary data.
	pub digest: Digest&lt;Hash::Output&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>这里简单对这个模板做介绍：</p>
<ul>
<li>parrent_hash：父区块hash，这里就不多做解释了，这是“区块链”概念的根本</li>
<li>number：区块高度，对于状态链必须，对于utxo链非必须（指代类似Bitcoin这类模型，而不是使用状态来模拟utxo），总体来说如果记录在header里面在其他部分的设计下可以简化一些，否则其他组件就会设计的比较复杂</li>
<li><code>state_root</code>：状态根，参考本系列<a href="https://zhuanlan.zhihu.com/p/96866051">《Substrate 入门 - 具备状态的链 -（三）》</a>，是对区块执行后状态变更的<strong>证明</strong></li>
<li><code>extrinsics_root</code>：交易根，代表了该header下的区块体中交易的内容与顺序，是对区块信息的<strong>摘要</strong></li>
<li><code>digest</code>，区块附加信息。digest翻译名“摘要”，但是这里笔者觉得这个类型更像是对区块信息的一些附加信息的集合，当前Substrate的文章及官方文档几乎都没对这个属性的剖析，但是其实它是相当重要的一个组成部分，后文会做分析。</li>
</ul>
<h3 id="2-框架外"><a class="header" href="#2-框架外">2. 框架外</a></h3>
<p>我们浏览一个模板范例<code>bin/node</code>中的例子：</p>
<p>文件<code>/bin/node/runtime/src/lib.rs</code> L528 左右</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Header = generic::Header&lt;BlockNumber, BlakeTwo256&gt;;
pub type Block = generic::Block&lt;Header, UncheckedExtrinsic&gt;; // Block 引用了上面Header的结构，UncheckedExtrinsic是交易，后续文章会介绍。因此Block中是可以看得到Header的结构，而这个结构是由用户定义了传入
<span class="boring">}
</span></code></pre></pre>
<p>L112行左右</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl frame_system::Trait for Runtime {
// ...
	type Header = generic::Header&lt;BlockNumber, BlakeTwo256&gt;; // 可以看到这里定义runtime内部Header的结构与上面对于Header的定义是一致的。
// ...
}
<span class="boring">}
</span></code></pre></pre>
<p>我们已知 node 中是用户编写的代码，因此我们可以注意到，用户代码中的<code>Header</code>是可以由<strong>用户自由定义</strong>的，包括并不限于如下改动：</p>
<ul>
<li>
<p>保留Substrate的框架内默认Header模板，即<code>generic::Header</code>，也就是位于<code>/primitives/runtime/src/generic/header.rs</code>中的定义：</p>
<ul>
<li>BlockNumber 是用 u32, u64，抑或时u128 等</li>
<li>对于BlockHash的计算使用的hash函数（这里是<code>BlakeTwo256</code>）</li>
</ul>
</li>
<li>
<p>重新使用自己定义的Header</p>
<ul>
<li>用户可自己定义自己的Header结构，一般情况下不适用，因为Header实际上和共识等组件是强耦合的，开发者<strong>唯有在知道自己该改的情况</strong>下才需要走这条路。</li>
</ul>
</li>
</ul>
<h3 id="简单分析"><a class="header" href="#简单分析">简单分析</a></h3>
<p>以上总结了在Substrate框架中Header的定义，可以看出，由于Substrate的框架属于状态类型的链，因此其提供的Header的模板是偏向于状态类型的定义，而且其Header类型提供的信息实际上和以太坊十分接近，不过一个很大的不同是将以太坊的收据根<code>receipt_root</code>移除了。</p>
<p>不过相对应的，Header中提供了一个新的类型digest，实际上这个类型是一个能附加很多额外信息的类型，例如对于收据根就可以附加在这里的，比如是pow的链需要提供nonce和bits这类的难度信息也可以附加到digest，除此之外其还提供了pos中出块者的签名，共识证明信息等等相当重要的信息。接下来做简单介绍。</p>
<h3 id="digest-的介绍"><a class="header" href="#digest-的介绍">digest 的介绍</a></h3>
<p>前文已经说过，digest更像是对于该区块其他所有附加信息的一个集合，现在简要分析如下：</p>
<p>见文件<code>/primitives/runtime/src/generic/digest.rs</code> L31 行左右：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Digest&lt;Hash: Encode + Decode&gt; {
	/// A list of logs in the digest.
	pub logs: Vec&lt;DigestItem&lt;Hash&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到，digest实际上是一个<code>DigestItem</code>的列表集合，因此可能每一个块都不同，其长度也不是固定的。因此<strong>如何解析Digest实际上是这条链的协议之一</strong>，是这条链的开发者应该重点进行设计的地方。</p>
<p><code>DigestItem</code>的定义见 L77 行</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DigestItem&lt;Hash&gt; {
	ChangesTrieRoot(Hash),
	PreRuntime(ConsensusEngineId, Vec&lt;u8&gt;),
	Consensus(ConsensusEngineId, Vec&lt;u8&gt;),
	Seal(ConsensusEngineId, Vec&lt;u8&gt;),
	/// Some other thing. Unsupported and experimental.
	Other(Vec&lt;u8&gt;),
}
<span class="boring">}
</span></code></pre></pre>
<p>由于本系列文章针对的是Substrate入门，因此本文仅对这些类型做介绍，至于如何使用这些及扩展不做详细说明。</p>
<ul>
<li><code>ChangesTrieRoot</code>：事实上是类似以太坊收据根<code>receipt_root</code>的一种加强版本（暂定），是对该块中<strong>每一条交易执行变更的证明</strong>，仅仅在该链genesis的时候决定是否启用。默认<strong>不启用</strong>。</li>
<li><code>PreRuntime</code>：对于部分PoS算法中必须，在Aura和Babe中用于记录轮到某个出块者出块的证明，如<code>Aura</code>中的<code>slot</code>，Babe中还会记录VRF证明等（见<code>/primitives/consensus/babe/src/digest.rs:L44</code>）。</li>
<li><code>Consensus</code>：对于部分PoS算法必须，用于记录共识算法中需要记录的特别的信息。如Aura/Babe中使用这个记录每个epoch验证者切换的列表。</li>
<li><code>Seal</code>：所有PoS算法必须，很多情况下用于记录这个产出这个区块的<strong>验证者的签名</strong>，因为在PoS中需要出块者使用的自己的私钥对区块进行签名，表面这个区块是由自己产出而不是别人产出。（PoW是靠难度，因此不需要签名）</li>
<li><code>Other</code>：扩展字段，因此<strong>一般对区块头的扩展</strong>都可以放在这里面，这里相当于编写链的人需要小心制定协议，如通过顺序，或者关键字等提取信息。这里可以扩展如：
<ul>
<li>PoW中的难度nbits与难度证明nonce</li>
</ul>
</li>
</ul>
<p>以上内容在编写轻节点以及区块链前端的时候相当重要，因为很多关键信息需要从Digest中解析得到（如这个区块的出块者，轻节点获取验证者变更的信息等）</p>
<p>这里特别强调以下对于DigestItem的编码的<code>Encode/Decode</code>需要遵从如下定义：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DigestItemType {
	ChangesTrieRoot = 2,
	PreRuntime = 6,
	Consensus = 4,
	Seal = 5,
	Other = 0,
}
<span class="boring">}
</span></code></pre></pre>
<p>对于<code>Encode/Decode</code>的特点后续会写一篇文章专门描述。这里是需要提醒前端的开发者需要特别注意这个编码顺序。</p>
<h2 id="总结-3"><a class="header" href="#总结-3">总结</a></h2>
<p>以上即是对Substrate的区块头定义的介绍，这里总体注意如下几点：</p>
<ol>
<li>Substrate的区块头是可以自由定义的，但是一般情况下应该沿用模板，除非有充足的理由去改变它</li>
<li>Substrate的区块头是偏向“状态链”的定义</li>
<li>Substrate的<code>Digest</code>属性需要特别注意，很多与共识相关的信息会记录在这里。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---交易体--六"><a class="header" href="#substrate-入门---交易体--六">Substrate 入门 - 交易体 -（六）</a></h1>
<p>上一篇文章讲解了区块的构成之一--区块头，本章介绍Substrate中构成区块体的部分，交易。</p>
<p>在Substrate中的交易不再称为<strong>Transaction</strong>，而是称为了<strong>Extrinsic</strong>，中文翻译就是“<strong>外部的；外表的；外源性</strong>”，意味着被称为Extrinsic的概念，对于区块链而言是外部的<strong>输入</strong>（关于这种模型描述笔者在一些分享中讲过，但是没写成文章，之后有空贴一些ppt）。这种定义脱离了本身“交易”的范畴（更像是转账的概念），而是在链的状态的角度下，认为交易及类似概念是一种改变状态的外部输入（意味着不止转账，只要是外部的操作都是）。</p>
<p>不过为了兼容区块链原生的概念，本文及之后的文章还是把Extrinsic称为交易，或者“输入”。</p>
<h2 id="定义"><a class="header" href="#定义">定义</a></h2>
<p>与Header不同，在Substrate中Extrinsic实际上具备极大的灵活性，能够允许开发者做出各种灵活的定制。</p>
<p>不过至少来说，一个“外部输入”至少会具备以下两个条件：</p>
<ul>
<li>发送者的证明</li>
<li>外部输入的行为</li>
</ul>
<p>其中第一点是显然的，只要基于公私钥体系，就一定需要发送者对这个发送的内容进行签名，在链上通过这个签名验证合法性，解析出发送者的公钥<strong>识别身份</strong>。等价于互联网中客户端持有的token这类的。而第二点就是这个“输入”是到链上干嘛的，其相当于是用户发送到链上的<strong>指令行为</strong>。</p>
<p>这两点对应到Substrate的交易模板上即为 <code>primitives/runtime/src/generic/unchecked_extrinsic.rs:L32</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A extrinsic right from the external world. This is unchecked and so
/// can contain a signature.
#[derive(PartialEq, Eq, Clone)]
pub struct UncheckedExtrinsic&lt;Address, Call, Signature, Extra&gt;
where
	Extra: SignedExtension
{
	/// The signature, address, number of extrinsics have come before from
	/// the same signer and an era describing the longevity of this transaction,
	/// if this is a signed extrinsic.
	pub signature: Option&lt;(Address, Signature, Extra)&gt;,  // 对应第一点
	/// The function that should be called.
	pub function: Call,  // 对应第二点
}
<span class="boring">}
</span></code></pre></pre>
<p>其中显然：</p>
<ul>
<li>signature: 就是发送者的身份标示与验证的信息</li>
<li>function: 就是发送者的意图指令，<strong>类型为<code>Call</code></strong>，用于调用链上的相应功能，例如转账<code>transfer</code>。这块即是一条<strong>链对外提供的功能</strong>，也是一条链的Runtime的入口组成部分。一个区块打包了所有的交易，执行区块的过程即是在Runtime中执行每一条交易的<code>function</code>的指令。这部分在后续的文章中将会详细讲解。</li>
</ul>
<p>这个交易模板实现了trait <code>primitives/runtime/src/traits.rs:L605</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>`primitives/runtime/src/traits.rs:L605`：/// Something that acts like an `Extrinsic`.
pub trait Extrinsic: Sized {
	type Call;
	type SignaturePayload;
	fn is_signed(&amp;self) -&gt; Option&lt;bool&gt; { None }
	fn new(_call: Self::Call, _signed_data: Option&lt;Self::SignaturePayload&gt;) -&gt; Option&lt;Self&gt; { None }
}
/// A &quot;checkable&quot; piece of information, used by the standard Substrate Executive in order to
/// check the validity of a piece of extrinsic information, usually by verifying the signature.
/// Implement for pieces of information that require some additional context `Context` in order to be
/// checked.
pub trait Checkable&lt;Context&gt;: Sized {
	type Checked;
	fn check(self, c: &amp;Context) -&gt; Result&lt;Self::Checked, TransactionValidityError&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>最终定义在Runtime中使用的交易的部分位于<code>bin/node/runtime/src/lib.rs:L566</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Unchecked extrinsic type as expected by this rundetime.
pub type UncheckedExtrinsic = generic::UncheckedExtrinsic&lt;Address, Call, Signature, SignedExtra&gt;;
// 其他用到 UncheckedExtrinsic 的就不写在这里了
<span class="boring">}
</span></code></pre></pre>
<h2 id="分析"><a class="header" href="#分析">分析</a></h2>
<p>实际上由于最后定义交易的部分位于node的runtime中，根据之前文章，大家应该可以清楚的意识到这里的<code>UncheckedExtrinsic</code>实现是可以任意替换的。</p>
<p>实际上只要实现了<code>Extrinsic</code>与<code>Checkable</code>这两个trait，就可以成为Substrate的<code>Extrinsic</code>，其中：</p>
<ul>
<li>前者提供了交易了功能性接口</li>
<li>后者提供了交易<strong>进入交易池前的验证</strong>接口</li>
</ul>
<p>这里的结构体<code>UncheckedExtrinsic</code>只是Substrate默认提供的模板，开发者完全可以替换成自己的结构体。不过绝大多数情况下都不需要罢了。</p>
<p>这里笔者重点说一下<code>UncheckedExtrinsic</code>中的<code>signature</code>。</p>
<p>我们可以看到<code>signature</code>由3个部分组成：</p>
<ul>
<li>Address  发送者的地址</li>
<li>Signature  发送者对交易体的签名</li>
<li>Extra  <strong>额外</strong>的验证信息</li>
</ul>
<p>这里很有意思的就是<code>Extra</code>这个东西。事实上这个部分可以允许开发者做很多事情，例如我们看以下在Substrate的node模板里面它做了<code>bin/node/runtime/src/lib.rs:L556</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The SignedExtension to the basic transaction logic.
pub type SignedExtra = (
	frame_system::CheckVersion&lt;Runtime&gt;,
	frame_system::CheckGenesis&lt;Runtime&gt;,
	frame_system::CheckEra&lt;Runtime&gt;,
	frame_system::CheckNonce&lt;Runtime&gt;,
	frame_system::CheckWeight&lt;Runtime&gt;,
	pallet_transaction_payment::ChargeTransactionPayment&lt;Runtime&gt;,
	pallet_contracts::CheckBlockGasLimit&lt;Runtime&gt;,
);
<span class="boring">}
</span></code></pre></pre>
<p>在讲解这个之前，首先要介绍一下一个Extrinsic从外部到链内部的过程：</p>
<p><img src="imgs/s6_1.png" alt="s6_1" /></p>
<p>我们首先要看到，Substrate并非是在执行区块的时候才开始校验交易合法性的，而是在进入交易池之前就开始校验了。同时在最后执行交易前还会再校验一遍。其过程为：</p>
<p>首先验证交易的签名合法性，然后验证**额外信息（Extra）**的合法性验证，才进入交易池。</p>
<p>这块验证流程位于<code>frame/executive/src/lib.rs</code>   这里请<strong>先记住<code>validate_transaction</code> 是进入交易池的验证过程</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	pub fn validate_transaction(uxt: Block::Extrinsic) -&gt; TransactionValidity {
		let encoded_len = uxt.using_encoded(|d| d.len());
		let xt = uxt.check(&amp;Default::default())?;   // 这里的check 来自 Checkable, 从 unchecked 变为 checked

		let dispatch_info = xt.get_dispatch_info();
		xt.validate::&lt;UnsignedValidator&gt;(dispatch_info, encoded_len)  // 这里对 checked 执行了 `validate` 进行额外信息的验证，请注意`validate`来自于 `SignedExtension` 这个trait
	}
<span class="boring">}
</span></code></pre></pre>
<p>而执行交易的流程为，这里请记住 <code>apply_extrinsic_with_len</code> 为真正执行交易的过程：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_extrinsic_with_len(
		uxt: Block::Extrinsic,
		encoded_len: usize,
		to_note: Option&lt;Vec&lt;u8&gt;&gt;,
	) -&gt; ApplyExtrinsicResult {
		// Verify that the signature is good.
		let xt = uxt.check(&amp;Default::default())?;  // 这里的check 来自于 Checkable，因此只执行了 check的过程（模板里即验签）
//...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>另一方面请注意</strong></p>
<p>由于刚才的<code>validate_transaction</code> 与<code>apply_extrinsic_with_len</code>都位于<code>frame/executive/</code>，因此实际上这个过程<em>根据前几篇文章</em>的介绍是**可以由开发者自己定义的！**因此开发者若觉得这个验证流程过于严格，或者不符合要求，完全可以修改这个验证过程。</p>
<p>还有需要注意的是，这里说的交易签名的验证是包括<code>Extra</code>提供的信息的。签名的校验指代的是对<code>function</code>和<code>extra</code>提供的附加验证条件进行校验。见<code>UncheckedExtrinsic</code>的实现（当然不使用模板自己实现的就可以更改这个过程），因此前端的交易组织签名的过程<strong>应与这里所匹配</strong>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Address, AccountId, Call, Signature, Extra, Lookup&gt; Checkable&lt;Lookup&gt; {
	type Checked = CheckedExtrinsic&lt;AccountId, Call, Extra&gt;;
	fn check(self, lookup: &amp;Lookup) -&gt; Result&lt;Self::Checked, TransactionValidityError&gt; {
		Ok(match self.signature {
			Some((signed, signature, extra)) =&gt; {
				let signed = lookup.lookup(signed)?;
				let raw_payload = SignedPayload::new(self.function, extra)?;  //注意这里将会把其他附加信息添加到raw_payload 中
				if !raw_payload.using_encoded(|payload| {
					signature.verify(payload, &amp;signed)  // 注意这里是对签名的 verify，对应的内容是`raw_payload`，因此前段的编码应和这里匹配
				}) {
					return Err(InvalidTransaction::BadProof.into())
				}
				// ...
			}
			// ...
		})
	}
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="extra"><a class="header" href="#extra">Extra</a></h2>
<p>笔者这里通过介绍Extra的实现方式介绍Substrate常见的一种对多种相同行为的最佳实践方式：</p>
<p>首先我们看<code>SignedPayload::new(self.function, extra)?; </code>的实现内容</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Call, Extra&gt; SignedPayload&lt;Call, Extra&gt; where
	Call: Encode,
	Extra: SignedExtension,
{	
	pub fn new(call: Call, extra: Extra) -&gt; Result&lt;Self, TransactionValidityError&gt; {
		let additional_signed = extra.additional_signed()?;  // 这里我们要观察到  extra 是一个实现了 `SignedExtension` 的类型，并执行了 `additional_signed` 附加了一些其他校验的元素

	}
}
<span class="boring">}
</span></code></pre></pre>
<p>而另一方面请注意，在<code>bin/node/runtime/src/lib.rs:L556</code> 与 <code>L566</code> 中：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type UncheckedExtrinsic = generic::UncheckedExtrinsic&lt;Address, Call, Signature, SignedExtra&gt;;
// 填充到交易模板的 SignedExtra 部分来自于 
pub type SignedExtra = (
	frame_system::CheckVersion&lt;Runtime&gt;,
	frame_system::CheckGenesis&lt;Runtime&gt;,
//... 
);
<span class="boring">}
</span></code></pre></pre>
<p>这里请注意，<code>SignedExtra</code> 是一个<strong>元组</strong>，并非是一个<code>SignedExtension</code>的具体实现体。</p>
<p>而随便点入一个校验查看，如 CheckEra： <code>frame/system/src/lib.rs:L1048</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	fn additional_signed(&amp;self) -&gt; Result&lt;Self::AdditionalSigned, TransactionValidityError&gt; {
		let current_u64 = &lt;Module&lt;T&gt;&gt;::block_number().saturated_into::&lt;u64&gt;();
		let n = (self.0).0.birth(current_u64).saturated_into::&lt;T::BlockNumber&gt;();
		if !&lt;BlockHash&lt;T&gt;&gt;::exists(n) {
			Err(InvalidTransaction::AncientBirthBlock.into())
		} else {
			Ok(&lt;Module&lt;T&gt;&gt;::block_hash(n))
		}
	}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>这里直接说明<code>Era</code>的作用实际上就是用于一个交易在交易池的存活条件。例如在比特币中，一个交易的手续费若太低，就会一直堆积在交易池中不被打包。而era就是在组件交易的时候附加一个条件，表面这个交易可以在交易池中存活多少个区块，若超出了这个区块范围还没被打包的话，就会从交易池中剔除。</p>
<p>因此比如若这里增加了这个判定条件，那么前端也要增加相应的参数，否则在刚才<code>validate_transaction</code>的过程中签名就会不匹配。</p>
</blockquote>
<p>我们可以看到这里的<code>additional_signed</code>已经是一个具体的实现。</p>
<p>那么在Substrate中是怎么从“元组”的执行走到“具体实现”的执行过程呢？</p>
<p>那么显然，Substrate实际上应该对元组实现<code>SignedExtra</code> 这个trait，而且实现内容大概就是</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SignedExtra for (A, B) {
    	fn additional_signed(&amp;self) -&gt; Result&lt;Self::AdditionalSigned, TransactionValidityError&gt; {
            let a = self.0.additional_signed()?;
            let b = self.1.additional_signed()?;
            Ok((a, b))  // 用某种方式把所有的 AdditionalSigned 拼起来
       }
}
<span class="boring">}
</span></code></pre></pre>
<p>会对元组中的每一个元组顺序执行，并把结果一并返回。因此在</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type UncheckedExtrinsic = generic::UncheckedExtrinsic&lt;Address, Call, Signature, SignedExtra&gt;;
// SignedExtra 这里的位置可以直接接受一个元组，否则若元组没有实现这个trait，是无法编译通过的。
<span class="boring">}
</span></code></pre></pre>
<p>而这里的实现实际上就位于：<code>primitives/runtime/src/traits.rs:L787</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[impl_for_tuples(1, 12)]
impl&lt;AccountId, Call, Info: Clone&gt; SignedExtension for Tuple {
    //...
}
<span class="boring">}
</span></code></pre></pre>
<p>这里Substrate已经用了过程宏的形式了，不需要深究的开发者倒是没必要搞的特别清楚。总之简单来说，通过这种形式，Substrate实现了类似：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SignedExtra for (A, ) {}
impl SignedExtra for (A, B) {}
impl SignedExtra for (A, B, C) {}  // 支持3元组
// .....
impl SignedExtra for (A,  B, C ....K , L) {} // 支持12元组
<span class="boring">}
</span></code></pre></pre>
<p>的这样一个过程。因此实际上能够传入<code>generic::UncheckedExtrinsic&lt;Address, Call, Signature, SignedExtra&gt;;</code>的SignedExtra的元组最大应该不能超过12个。</p>
<p><strong>Substrate在Runtime的很多基础库的实现都采用了类似的方式</strong>，因此在定义runtime的地方<code>bin/node/runtime/src/lib.rs</code>经常可以看到这种元组传入定义的形式。</p>
<p>另一方面由于<code>additional_signed</code>的返回值是影响交易签名的验证的，因此前端应注意，附加这些额外验证信息的时候，其顺序应该与在<code>bin/node/runtime/src/lib.rs</code><strong>中<code>SignedExtra</code>元组的顺序相同</strong></p>
<h2 id="总结-4"><a class="header" href="#总结-4">总结</a></h2>
<p>本文介绍了Substrate中交易的设计方式。通过分析可以看出，Substrate的交易实际上设计的具备极强的扩展性，开发者完全可以根据自己的功能需求。</p>
<p>文中只讲解了其原理，没讲其是怎么使用的。这里简单说一下，Substrate可以用这种模型实现。</p>
<ul>
<li>手续费检查</li>
<li>手续费检查</li>
<li>交易版本与链上版本检查</li>
<li>交易存活性检查</li>
<li>特殊交易的额外信息检查
<ul>
<li>例如如果一个交易是转账transfer，可以直接检查发送者的余额是否足够，不用到区块执行阶段才判定。</li>
</ul>
</li>
</ul>
<p>因此在明白了substrate的交易设计后，可以灵活的根据需求对其进行改动。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---substrate的模型设计--七"><a class="header" href="#substrate-入门---substrate的模型设计--七">Substrate 入门 - Substrate的模型设计 -（七）</a></h1>
<p>上两篇已经描述了Substrate对与“区块链”的基本元素 -- 区块头 与 交易 的设计，后续的文章将会着重开始介绍Substrate对于开发者开放的核心设施-- Runtime。因此本文首先需要重新更加具体的介绍Substrate的设计模型，在有这个概念的基础上后续才能方便讲解。</p>
<h2 id="程序与具备逻辑功能区块链"><a class="header" href="#程序与具备逻辑功能区块链">程序与具备逻辑功能区块链</a></h2>
<p><img src="imgs/s7_1.png" alt="s7_1" /></p>
<p>如图所示，我们将现代计算机的程序模型与当前的区块链模型比较，可以得到如下的抽象：</p>
<ol>
<li>程序由指令与数据构成，对应到链上即为链上代码（例如以太坊的合约，fabric的chaincode，substrate的Runtime）和链上存储（以太坊和fabric都叫做世界状态world state，Substrate中叫Runtime Storage，也是世界状态）</li>
<li>程序接受用户的输入，经过处理后得到输出，对应到链即为接受区块中的交易，执行后修改状态。用户可以以<strong>异步</strong>的方式去查询执行后的结果以代表执行后的输出。请注意区块由于需要经过共识的过程，因此对于结果的判定一定得等到区块的共识达成（又称为区块finality后），才能进行查询。因此区块链是一个异步的系统。这里接受交易的调用即是接受一个Extrinsic，外部的的输入。</li>
<li>程序需要运行在计算机的操作系统环境里（非指代无需操作系统的程序），对应到链而言是运行链上代码所需要的一个<strong>沙盒</strong>环境，这个沙盒环境是要去除io，网络访问等会产生“副作用”的沙盒。在以太坊中这个环境是EVM，fabric是docker，substrate中即是Runtime的运行环境。</li>
</ol>
<p>因此我们可以看出，在这种角度的抽象上，区块链的系统与正常的程序的模型实际上是非常相似的。</p>
<h2 id="区块链与模型的对应关系"><a class="header" href="#区块链与模型的对应关系">区块链与模型的对应关系</a></h2>
<p>那么对应于上图右边部分区块链模型的描述，一些具体的链即对应如下的情况：</p>
<p><img src="imgs/s7_2.png" alt="s7_2" /></p>
<p>以太坊这里就不再赘述了，从Substrate开始。在Substrate中，<strong>广义上</strong>我们一般把整个链上运行环境，包含链上代码与链上存储，整体称为Runtime。</p>
<p>不过一般<strong>狭义上</strong>我们只把链上代码称为Runtime，也就是使用Substrate的链开发者需要主要进行开发的部分，而链上的数据我们称为Runtime Storage。执行链上代码的执行器及环境我们称为Runtime执行环境。</p>
<p>Substrate的Runtime执行环境的特别之处在于，其设计为了“同一套代码编译出2种执行文件”。其设计原理与优势请参考《<a href="https://zhuanlan.zhihu.com/p/56383616">Substrate 设计总览</a>》这篇文章。</p>
<p>Substrate对于Runtime(狭义)编译出的WASM版本，需要存在于“链上存储”才可生效，又由于“链上存储”是所有节点都共享的数据，因此对于所有节点而言，若执行的是WASM版本的，则一定是同一份代码。</p>
<p>Substrate的Runtime是携带Runtime的版本信息的<code>bin/node/runtime/src/lib.rs:L73</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Runtime version.
pub const VERSION: RuntimeVersion = RuntimeVersion {
	spec_name: create_runtime_str!(&quot;node&quot;),
	impl_name: create_runtime_str!(&quot;substrate-node&quot;),
	authoring_version: 10,
	// Per convention: if the runtime behavior changes, increment spec_version
	// and set impl_version to equal spec_version. If only runtime
	// implementation changes and behavior does not, then leave spec_version as
	// is and increment impl_version.
	spec_version: 198,
	impl_version: 198,
	apis: RUNTIME_API_VERSIONS,
};
<span class="boring">}
</span></code></pre></pre>
<p>注意<code>spec_version</code>上方的注释，这里说明了对于Substrate的Runtime的执行器而言，认准的是<code>spec_version</code>的值。（<code>spec_version</code>是代码里面的一个<strong>常量</strong>）请注意由于Runtime是一份代码编译出2份执行文件，因此例如改动了<code>spec_version</code>的值，编译节点称为了新的节点，但是没有编译wasm，则从wasm代码里面取出的<code>spec_version</code>一定与新编译出的节点二进制中保留的<code>spec_version</code>的值不同。参见《<a href="https://zhuanlan.zhihu.com/p/56383616">Substrate 设计总览</a>》中的介绍，对于Substrate的Runtime执行器而言，当版本信息不同时，会采用WASM版本的为准。（当然若是一个恶意节点自己改动了Runtime执行器的代码，例如就是只认本地native的版本信息，那么当然也是可以的。只是只要不是绝大多数人都是恶意节点，那么链就只会遵循绝大多数人的共识进行。因此只要非恶意节点都是遵循了这个规则，那么它就是有效的。）</p>
<p>在《<a href="https://zhuanlan.zhihu.com/p/94879423">Substrate 入门 - 运行与调试 -（二）</a>》中介绍了若希望以debug的形式调试，一定要运行native，其指代的就是和这部分有关。在现在这个版本的Substrate里，我们对node执行<code>--help | grep exec</code>可以看到和执行相关的命令：</p>
<ul>
<li><code>--execution</code>  : 对于所有的执行采用的方式</li>
<li><code>--execution-block-construction</code> ： 对于打包区块执行的时候采用的方式</li>
<li><code>--execution-import-block</code>：从文件导入区块执行的时候采用的方式</li>
<li><code>--execution-offchain-worker</code>：offchain 执行的时候采用的方式</li>
<li><code>--execution-other</code> ：在他调用api的时候采用的方式，如设置内部交易，rpc调用等其他环节</li>
<li><code>--execution-syncing</code>：从p2p同步区块的时候采用的方式</li>
</ul>
<p>以上的指令能接受的参数都有：<code>Native, Wasm, Both, NativeElseWasm</code>，从命名方式上应该就可以看出其特点。但总体来说，这些命令从本质上来说，就是指代在执行不同情况下的时候，<strong>应该采用哪一份（native/wasm）代码</strong>。</p>
<p>由于在之前的模型抽象部分已经介绍了，对于“执行环境”而言，其本质是一个沙盒，且需要避免一些会带来副作用（相同的执行可能会产生不同的结果）的情况，因此虽然在Substrate中的Runtime是由Rust编写，可以编译成为Rust的native代码及wasm代码，但<strong>其本质上并非能调用到Rust的所有std库提供的接口，同时若引入新的库，若只支持std，不支持no_std的库也是无法通过编译的。</strong></p>
<p>若对这套体系不清楚的话，简单的来说请注意，所有需要出现在Runtime编译依赖的库中，其<code>Cargo.toml</code>的最后几行都会出现：</p>
<pre><code class="language-toml">[dependencies]
# 在 dependencies 中，一定要有 default-features = false
frame-system = { version = &quot;2.0.0&quot;, default-features = false, path = &quot;../system&quot; } 
# ... 
[features]
default = [&quot;std&quot;]
std = [
	&quot;serde&quot;,
	&quot;codec/std&quot;,
	&quot;sp-std/std&quot;,
	&quot;sp-io/std&quot;,
    # ...
]
</code></pre>
<p>这样的字样。这里表示<code>default</code>的feature是“std”，且对于<code>dependencies</code> 中的依赖，一定是不启用默认features的（<code>default-features</code>）</p>
<p>且在该crate的根目录下的<code>lib.rs</code>的前几行，一定会出现</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
<span class="boring">fn main() {
</span><span class="boring">}
</span></code></pre></pre>
<p>这样的条件编译的字样。这里表示“若没有在std的条件编译下，则对于该crate采用<code>no_std</code>”。</p>
<p><strong>另一方面，广义的Runtime即是这条链的“业务逻辑”，也就是“链的功能”。</strong></p>
<h2 id="总结-5"><a class="header" href="#总结-5">总结</a></h2>
<p>本文从一个角度描述了当前区块链的设计模型框架，并介绍了在这个框架下，Substrate是如何的一种对应关系。并且强调了在Substrate中，其执行器是以“同一份代码，两种可执行文件”的形式存在，且联系了之前对于Substrate概要设计的介绍，关联起来了区块链设计模型与Substrate的概要设计之间的关系。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---runtime概要--八"><a class="header" href="#substrate-入门---runtime概要--八">Substrate 入门 - Runtime概要 -（八）</a></h1>
<p>承接上一篇文章，在介绍了Substrate的模型设计后，终于可以开始进行Substrate的Runtime部分的介绍。本篇首先介绍Runtime的概要模型，为后续文章打下基础。</p>
<p>上一篇文章已经介绍了对于运行“链上代码”的部分是一个沙盒，因此Runtime的模型从本质上而言就是一个与其他环境隔绝的沙盒。那么对于一个沙盒而言，由于其与外界隔绝，因此必定有相应的口子让Runtime与外界进行交互。因此Runtime对外开的口子主要分为2类：</p>
<ul>
<li>IO：负责Runtime Storage 的Read/Write.</li>
<li>API：Runtime与一切外界元素交互的入口，例如：
<ul>
<li><strong>创建区块</strong></li>
<li><strong>执行交易</strong></li>
<li><strong>验证交易合法性</strong></li>
<li>Runtime的metadata （关于metadata今后专门撰写文章介绍）</li>
<li>结构化读取Runtime存储</li>
<li>执行合约</li>
<li>等等...</li>
</ul>
</li>
</ul>
<h2 id="runtime的模型概要"><a class="header" href="#runtime的模型概要">Runtime的模型概要</a></h2>
<p>Runtime的模型本质上如下所示：</p>
<p><img src="imgs/s8_1.png" alt="s8_1" /></p>
<p>实际上图中所示的已经是最简化版本，这里只是表明这个意思，实际的实现还要更复杂一下。在图中需要留意的关键有以下几点：</p>
<h3 id="1-runtime-对外层的接口"><a class="header" href="#1-runtime-对外层的接口">1. Runtime 对外层的接口</a></h3>
<p>在图中明显的表明，Runtime对外层的接口实际上只有两种：</p>
<ul>
<li>IO</li>
<li>API</li>
</ul>
<p>其中IO是对于开发者不可见的，对于Runtime的IO接口后续会专门撰写进行介绍。本文重点介绍API接口。</p>
<p>这里的API我们命名为Runtime API，其在Runtime的运转中具有极其重要的意义。不过由于最关键的区块构建，交易执行的api由Substrate Core 负责了，因此对于普通开发者而言，懂个大概就足够了。</p>
<p>这里要专门介绍Runtime的意义在于，与区块链的模型相比，<strong>可以看出Substrate的Runtime抽象力争于将“Runtime的概念”与“链”的概念进行解耦，让Runtime脱离链的执行环境（打包区块，执行交易），转而成为是Runtime向外界提供构建区块，执行交易的接口</strong>。</p>
<p>因此在其他区块链模型中，一般遵循：</p>
<blockquote>
<p>出块打包/同步区块 -&gt; 执行 -&gt; 创建环境 -&gt; 调用交易中对应的某个函数接口</p>
</blockquote>
<p>而在Substrate的Runtime模型中，遵循</p>
<blockquote>
<p>出块打包/同步区块 -&gt; 执行 -&gt; 创建环境 -&gt; <strong>调用Runtime的执行区块api</strong> -&gt; 进入Runtime层（在执行区块的过程中，才会调用交易中对应的函数接口）</p>
</blockquote>
<p>因此在这种模型下，一个完整的Runtime<strong>可以承载在不同的外界环境中运行</strong>：</p>
<ol>
<li>例如使用c++重新实现Runtime的执行环境体</li>
<li>在浏览器中运行WASM</li>
<li>波卡的<strong>分片跨链的平行链</strong></li>
<li>等等...</li>
</ol>
<p>因此我们在Substrate的runtime构建的过程中，可以看到其为Runtime定义了一些<code>Core</code>的api，用于执行区块链的核心逻辑：</p>
<p>定义api代码：<code>primitives/api/src/lib.rs:L464</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>decl_runtime_apis! {
   /// The `Core` runtime api that every Substrate runtime needs to implement.
   #[core_trait]
   #[api_version(2)]
   pub trait Core {
      /// Returns the version of the runtime.
      fn version() -&gt; RuntimeVersion;
      /// Execute the given block.
      #[skip_initialize_block]
      fn execute_block(block: Block);
      /// Initialize a block with the given header.
      #[renamed(&quot;initialise_block&quot;, 2)]
      #[skip_initialize_block]
      #[initialize_block]
      fn initialize_block(header: &amp;&lt;Block as BlockT&gt;::Header);
   }

   /// The `Metadata` api trait that returns metadata for the runtime.
   pub trait Metadata {
      /// Returns the metadata of a runtime.
      fn metadata() -&gt; OpaqueMetadata;
   }
}
<span class="boring">}
</span></code></pre></pre>
<p>实现代码：<code>bin/node/runtime/src/lib.rs:L609</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl_runtime_apis! {
   impl sp_api::Core&lt;Block&gt; for Runtime {
      fn version() -&gt; RuntimeVersion {
         VERSION
      }

      fn execute_block(block: Block) {
         Executive::execute_block(block)
      }

      fn initialize_block(header: &amp;&lt;Block as BlockT&gt;::Header) {
         Executive::initialize_block(header)
      }
   }
    // metadata...

   impl sp_block_builder::BlockBuilder&lt;Block&gt; for Runtime {
      fn apply_extrinsic(extrinsic: &lt;Block as BlockT&gt;::Extrinsic) -&gt; ApplyExtrinsicResult {
         Executive::apply_extrinsic(extrinsic)
      }
		// ...
   }
	//...
}
<span class="boring">}
</span></code></pre></pre>
<p>在Substrate中，对于API的实现极其复杂，采用了很多宏的实现。由于本系列只是入门，所以这里我们不探究宏背后的实现，直接给出案例说明结论：</p>
<p>对于一个API，首先需要对其进行声明，通过宏<code>decl_runtime_apis!</code>，然后对应于声明过的宏，需要在Runtime内部（例如在<code>node/runtime/src</code>下）对其进行实现，而实现的方式也只能通过宏<code>impl_runtime_apis!</code></p>
<p>毕竟Substrate是以“区块链”的模型存在的，因此我们可以看到在<code>primitives/api/src/lib.rs</code>中声明了<code>Core</code>的api（注意这里位于的包是在primitives下，参见前几文章对模块分类的介绍）。在这个api的声明中，拥有3个关键的接口：</p>
<ul>
<li><code>version</code>  Runtime的版本，参见之前文章对Runtime版本的介绍</li>
<li><code>execute_block</code> 执行一个区块，接受的参数是<code>Block</code></li>
<li><code>initialize_block</code> 初始化一个区块，注意这个函数接受的参数是<code>Header</code></li>
</ul>
<p>可以看到这个接口覆盖了一个链的基本核心，因此每一条链至少都必须实现这里定义的<code>Core</code>API接口。</p>
<p>另一方面我们观察他的实现，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn execute_block(block: Block) {
	Executive::execute_block(block)
}
<span class="boring">}
</span></code></pre></pre>
<p>其中调用了<code>Executive</code>的函数。请注意这里的Executive已经是Runtime的内部模块了，其对应的<code>frame</code>中的<code>executive</code>包<code>frame/executive/</code>，参见之前的对于模块分类的文章，我们可知实际上这里的<code>Executive::execute_block(block)</code>是可以被任意替换的，这意味着开发者完全可以实现自己的区块执行逻辑，且若更改了这个执行逻辑，在任意能承载Runtime运行的平台上<strong>都可以统一运行</strong>，而<strong>不需要把不同平台的区块执行逻辑都做相同更改</strong>（结合上文描述Runtime运载不同平台的介绍）。</p>
<p>另一方面我们来看看另一个api接口<code>BlockBuilder</code></p>
<p>该接口专门负责的一个区块的构建过程，（与刚才<code>Core</code>中的执行区块分开，这里的区块的提议过程proposal）。</p>
<p>这里我们只看<code>apply_extrinsic</code>这个接口，这个接口即是打包区块过程中的执行交易接口。显然要执行交易，其交易一定是从外部传入进来的，那么我们可以跟随这个接口，介绍一下Runtime是如何与外部通过api进行交互的。</p>
<h3 id="2-外部与runtime交互的方式"><a class="header" href="#2-外部与runtime交互的方式">2. 外部与Runtime交互的方式</a></h3>
<p>在一开始的图里，笔者显然支出一个api的调用，必定需要包裹在<code>Client</code>里。在后文介绍API和client的关系。这里我们跳过这层关系，直接找一个区块的打包过程。</p>
<p>显然一个区块能被创建出来，其<strong>必定是在共识流程</strong>中，在Pos中，一般都会推选出一个proposer来构建出这个区块，这里直接指出代码位于<code>/client/basic-authorship/src/lib.rs:L169</code>（注意这里位于client目录下）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut block_builder = self.client.new_block_at(
			&amp;self.parent_id,
			inherent_digests,
			record_proof,
		)?;

		// We don't check the API versions any further here since the dispatch compatibility
		// check should be enough.
		for extrinsic in self.client.runtime_api()
			.inherent_extrinsics_with_context(
				&amp;self.parent_id,
				ExecutionContext::BlockConstruction,
				inherent_data
			)?
		{
			block_builder.push(extrinsic)?;  // 这里出现了 builder.push()
		}
		//...
		debug!(&quot;Attempting to push transactions from the pool.&quot;);
		for pending_tx in pending_iterator {
		//...
			let pending_tx_data = pending_tx.data().clone();
			let pending_tx_hash = pending_tx.hash().clone();
			trace!(&quot;[{:?}] Pushing to the block.&quot;, pending_tx_hash);
            // 这里即是打包区块的过程，将交易push进入 builder 过程中，这里的Push和刚才的Push一致
			match sc_block_builder::BlockBuilder::push(&amp;mut block_builder, pending_tx_data) {
				Ok(()) =&gt; {
					debug!(&quot;[{:?}] Pushed to the block.&quot;, pending_tx_hash);
				}
                // ...
            }
         // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>而我们来看一下<code>push</code>的实现<code>client/block-builder/src/lib.rs:L128</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn push(&amp;mut self, xt: &lt;Block as BlockT&gt;::Extrinsic) -&gt; Result&lt;(), ApiErrorFor&lt;A, Block&gt;&gt; {
		let block_id = &amp;self.block_id;
		let extrinsics = &amp;mut self.extrinsics;

		if  // ...
		{
			// ...
		} else {
            // 请注意这里的 api.map_api_result
			self.api.map_api_result(|api| {
                // 请注意这里的 api.apply_extrinsic_with_context
				match api.apply_extrinsic_with_context(
					block_id,
					ExecutionContext::BlockConstruction,
					xt.clone(),
				)? {
					// ...
				}
			})
		}
	}
<span class="boring">}
</span></code></pre></pre>
<p>由于宏展开的过程十分复杂，这里直接告诉读者，这里的<code>apply_extrinsic_with_context</code> 实际上最后即调用到了runtime中对于api的实现体：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	impl sp_block_builder::BlockBuilder&lt;Block&gt; for Runtime {
		fn apply_extrinsic(extrinsic: &lt;Block as BlockT&gt;::Extrinsic) -&gt; ApplyExtrinsicResult {
			Executive::apply_extrinsic(extrinsic)
		}
}
<span class="boring">}
</span></code></pre></pre>
<p>中，也就是说<code>apply_extrinsic_with_context</code>在一系列的宏张开的调用过程中，最后调用到了runtime层，调用了<code>apply_extrinsic</code>，并进而调用了真正的实现体<code>Executive::apply_extrinsic(extrinsic)</code></p>
<p>读者只需要记住，定义的Runtime的api，通过宏展开后，会在生成：</p>
<ul>
<li>原名函数</li>
<li>原名函数_with_context  (这里的context主要是为区分不同的执行上下文，需要提供一个不同的context环境，否则在原函数名称的实现中，默认会传入<code>Context::OffchainCall(None)</code>)</li>
</ul>
<p>这个生成的函数实际上是赋予的Runtime的Api对象<code>RuntimeApiImpl</code>，这里不展开这个是怎么来的，只需要明白在<code>impl_runtime_apis</code>展开后，对于原函数的实现会<strong>包装</strong>一些如一开始的图中的调用实现，然后会生成一个api对象，这个对象最后会<strong>赋给client的api属性</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;B, E, Block, RA&gt; Client&lt;B, E, Block, RA&gt; {	
	pub fn new_block(
		&amp;self,
		inherent_digests: DigestFor&lt;Block&gt;,
	) -&gt; sp_blockchain::Result&lt;sc_block_builder::BlockBuilder&lt;Block, Self, B&gt;&gt; where	
///
	{
		let info = self.chain_info();
		sc_block_builder::BlockBuilder::new(
			self,  // 注意这里的 BlockBuilder 的 api_ref 参数传入的是 self，也就是说是client自身
            //..
        )
    }
}
impl&lt;'a, Block, A, B&gt; BlockBuilder&lt;'a, Block, A, B&gt; {
    pub fn new(
		api: &amp;'a A,
		parent_hash: Block::Hash,
		parent_number: NumberFor&lt;Block&gt;,
		record_proof: RecordProof,
		inherent_digests: DigestFor&lt;Block&gt;,
		backend: &amp;'a B,
	) -&gt; Result&lt;Self, ApiErrorFor&lt;A, Block&gt;&gt; {
        // 留意这里的header
		let header = &lt;&lt;Block as BlockT&gt;::Header as HeaderT&gt;::new(
			parent_number + One::one(),  // 请留意这里的header是在parent 上+1，即意味着下一个区块！
			//...
		);
		let mut api = api.runtime_api();
		//...
        let block_id = BlockId::Hash(parent_hash); // 注意这里的 block_id 来自的是 parent!!!
        // 这里的 initialize_block_with_context 即是调用了runtime 的api实现里`Core`下的initialize_block函数
		api.initialize_block_with_context(
			&amp;block_id, ExecutionContext::BlockConstruction, &amp;header,
		)?;

		Ok(Self {
			parent_hash,
			extrinsics: Vec::new(),
			api,  // 这里的api即是来自client
			block_id, // 这里传入的是 parent （也就是当前最新区块）的blockid
			backend,
		})
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>由以上这段代码可以看出，client自身可以通过<code>runtime_api</code>获取到api实例（这里就不介绍怎么来的了），通过api可以调用<code>initialize_block_with_context</code>，然后block_builder会持有这个api引用，因而在<code>push</code>里面可以通过api调用<code>apply_extrinsic_with_context</code>。</p>
<p>因此整个过程就梳理清楚了，Substrate抽象了Runtime，并且对于Runtime对外界的接口采用了定义api，实现api的方式。这种api的形式会<strong>通过宏展开的形式</strong>，将定义的api的调用方式赋予给Runtime外层的client对象。而在笔者比较早期的文章介绍过，substrate的架构实现实际上和<code>c++</code>版本的Ethereum近似，所以这里的client和c++的Ethereum一样，**实际上是一个节点运行中的单例，持有了所有的运行时对象并具备访问数据库能力的一个集合对象。**通过client可以调用到Runtime的api，进而实例化Runtime并进行相应函数的调用。</p>
<p>那么这里的问题就随之就来了，通过外部调用runtime的api，需要通过如此复杂的宏展开的方式么？答案是：其实不一定，但是目前似乎是这么做最好。</p>
<p>理由就是我们首先需要观察到，在runtime内的api定义的函数，与api调用的函数有什么区别？</p>
<h3 id="3-外部加载状态调用的runtime"><a class="header" href="#3-外部加载状态调用的runtime">3. 外部加载状态调用的Runtime</a></h3>
<p>那么在外界api可以调用的<code>apply_extrinsic</code>并附带函数签名是：</p>
<ul>
<li><code>apply_extrinsic_with_context(block_id: BlockId, context: sp_api::ExecutionContext, e: xt: &lt;Block as BlockT&gt;::Extrinsic)</code></li>
<li><code>apply_extrinsic(block_id: BlockId, context: sp_api::ExecutionContext, e: xt: &lt;Block as BlockT&gt;::Extrinsic)</code></li>
</ul>
<p>这里直接告诉读者带<code>_with_context</code>的版本与不带的其他部分实现是一样的，区别只是在于提供的context，而不带的版本默认为<code>Context::OffchainCall(None)</code></p>
<p>而在Runtime内定义的函数签名为</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn apply_extrinsic(extrinsic: &lt;Block as BlockT&gt;::Extrinsic);
<span class="boring">}
</span></code></pre></pre>
<p>如果比较不带<code>_with_context</code>的版本，我们可以显然的注意到在外部调用的api的版本中，与在Runtime中定义的相比，多了一个<code>blockid</code>。</p>
<p>实际上这里的blockid即是一个状态区块链运行的核心 -- 基于某个状态去执行Runtime。</p>
<p>在2的部分中，代码的注释里，笔者强调了注意blockid传入的值是什么。由于构建区块显然是要基于最新（或该节点认为应该基于的区块）状态进行构建，因此传入了<code>parent</code>。</p>
<p>在本文开头的图里，有一个虚线框框住了<code>state</code>,<code>executor</code>,<code>backend</code>等，并表明这个框的内部都是由宏展开实现的。api通过<code>call_api_at</code>(其也是宏展开内的东西)，基于一个给予的state（即通过调用api时传入的blockid），创建环境并调用执行器去执行。在这个执行环境下，Runtime的IO读取，即Runtime Storage也是在该环境下基于该State进行读写。</p>
<p><strong>显然若指定了不同的State，那么执行api时基于的环境就将会不同，因此例如想要实现读取过去的状态等功能时，即是通过状态不同的状态实现</strong></p>
<p>而关于不同的State的细节，请参考笔者之前关于<a href="https://zhuanlan.zhihu.com/p/96866051">《基于状态的链》</a>的相关文章</p>
<p>因此若不管所有细节，读者需要明白的就是：</p>
<p><strong>对于Runtime对外通过api定义并暴露的接口，在Runtime外通过api调用时，需要指定执行该api需要基础的状态，即表明“基于某个状态去执行Runtime的api调用”</strong></p>
<p>而这个状态即是通过宏展开的api的第一个参数blockid去指定。</p>
<h2 id="总结-6"><a class="header" href="#总结-6">总结</a></h2>
<p>Substrate的Runtime抽象在笔者看来是一个比较出色的抽象，其将Runtime的概念与区块链本身进行的剥离，虽然通过比较奇怪且难以理解的宏的实现方式，**但是将Runtime的api与外界调用api的过程进行的挂接，使得加载一个Runtime需要通过一个状态去执行。**在这里调用过程中封装了许多复杂的过程，本文不展开讲解，因此读者只需要记住2点：</p>
<ol>
<li>外界沟通Runtime的方式的唯一入口是通过Runtime的api，api可以由开发者自由定制</li>
<li>调用api的时候需要装载执行这个api时基于的环境，加载了不同的状态，那么意味着在这个状态下去执行api</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---runtime的wasm与native--九"><a class="header" href="#substrate-入门---runtime的wasm与native--九">Substrate 入门 - Runtime的wasm与native -（九）</a></h1>
<p>上一篇文章已经介绍了Substrate Runtime的设计概要，结合之前的文章，在此设计的基础上我们必须明白以下几点：</p>
<ol>
<li>Runtime 是一个隔离的环境，其通过api与外界通信，通信时需要加载上指定块高以对应加载的状态</li>
<li>Substrate的Runtime是同一份代码编译出两种执行文件，rust的native与能在wasm虚拟机下运行的wasm，通过启动节点时制定的参与及硬编码进入执行文件中的Runtime版本信息觉得执行哪一份文件</li>
</ol>
<p>因此本篇文章就来具体介绍Runtime编译成wasm所需要的条件。</p>
<p><strong>本篇只会介绍创建或引入一个包进入Runtime的wasm体系所需要注意的点，至于其需要这么做的原理暂不在本篇中介绍。</strong></p>
<h2 id="runtime-的wasm"><a class="header" href="#runtime-的wasm">Runtime 的WASM</a></h2>
<p>这里首先就放出结论：</p>
<p><strong>Substrate的Runtime的WASM并非标准WASM，而是是一个有条件限制的wasm，并非所有代码都可以编译成Runtime的WASM</strong></p>
<p>而这个“有条件”即是本篇文章需要指明的内容。</p>
<p>因此很多使用Substrate写Runtime部分的程序员，经常遇到的一个问题就是：</p>
<p>“为什么我把一个库引入Runtime后就编译不过了”</p>
<p>所以到这里，开发者应该明白Substrate的Runtime WASM是要受到条件制约的，因为对于链而言，并不是什么东西都可以放在Runtime环境中的，例如在之前的文章中提到，<strong>由于共识的限制，需要每个节点执行相同代码得到相同的结果</strong>，因此在Runtime中能够执行的应该是“没有副作用”逻辑，如：</p>
<ol>
<li>系统调用（操作系统函数）</li>
<li>网络、磁盘访问（因此被限制了io）</li>
<li><strong>全局单例变量</strong>（由于在执行每个块的每个交易中wasm环境都是重新创建的，因此在Substrate中都是存到某个存储中，在finalize的时候删除）</li>
<li>... 等等其他</li>
</ol>
<p>因此在Substrate的Runtime以上的依赖中，需要严格区分<code>std</code>与<code>no_std</code>，也就是对应着native与Runtime wasm（后文简称wasm）。而且这里的<code>no_std</code>是Rust能编译成wasm的库中的一个<strong>子集</strong>（当前剔除了一些类型，详情见：<code>primitives/std/without_std.rs</code>中提供的类型）</p>
<h2 id="runtime-的依赖"><a class="header" href="#runtime-的依赖">Runtime 的依赖</a></h2>
<blockquote>
<p>sp-std  sp-io</p>
<p>|               |</p>
<p>|           frame-support  frame-system</p>
<p>|            /</p>
<p>frame-assets frame-balances ...</p>
<p>|      /</p>
<p>node-runtime</p>
</blockquote>
<p>例如当前对于node节点项目而言，依赖的简化版本如上。这里列出这个依赖只是想说明如下：</p>
<p><strong>对于Runtime而言，node-runtime作为整个依赖树末端的叶，以其为根基往上的所有依赖都要满足上一节提到的“条件”，直到依赖的根</strong></p>
<p>因此只要编写了会进入<code>node-runtime</code>依赖树的crate，那么即便其可能被在非Runtime的部分中被引用到，那么其也必须满足这一些条件。否则<strong>如果这个库不满足这条件，那么只能以<code>optional</code>的形式引入，使其只能在native下编译，不能在wasm下编译</strong></p>
<h2 id="能编译成wasm的条件"><a class="header" href="#能编译成wasm的条件">能编译成WASM的条件</a></h2>
<p>以下内容若不清楚原理，那么<strong>直接照抄</strong>即可。若希望自己探究原理，请记住在Substrate Runtime设计中，区分WASM和Native编译过程中引入什么库是通过**“条件编译”**控制的。今后写Substrate进阶或深入文章的时候笔者再来自己剖析其中原理。</p>
<h3 id="1-runtime依赖树中的crate的cargotoml-的编写"><a class="header" href="#1-runtime依赖树中的crate的cargotoml-的编写">1. Runtime依赖树中的crate的Cargo.toml 的编写</a></h3>
<p>一个能在Runtime里面被引用的库，其<code>Cargo.toml</code>必须按照如下方式编写：</p>
<ol>
<li>在<code>dependencies</code>一栏中，一个库的引入要么指定了<code>default-features = false</code>，要不指定为<code>optional = true</code>。
<ol>
<li>若指定为<code>default-features = false</code>，那么进入这个被依赖的包，其<code>Cargo.toml</code>在<code>features</code>这一栏中必须指定过<code>default = [&quot;std&quot;]</code>。（非严禁说法，若不知道为什么，照做，若知道，根据自己需求变更）</li>
<li>若指定为<code>optional = true</code>，那么这个被依赖包只可以被native编译，不可以被wasm编译，在当前包中引用它时，需要加上<code>#[cfg(feature = &quot;std&quot;)]</code>的条件编译</li>
</ol>
</li>
<li>在<code>[features]</code>一栏中，一定要按照如下方式写
<ol>
<li><code>default = [&quot;std&quot;]</code> ，将当前的default feature <strong>指定为<code>std</code>，一定不能少</strong></li>
<li><code>std = [&quot;serde&quot;, &quot;codec/std&quot;, ... ]</code> ，在<code>dependencies</code>中出现过的库名，一定要出现在<code>std</code>feature对应的<strong>列表</strong>中，其中在<code>dependencies</code>中（以下两点皆为非严禁说法，若不知道为什么，照做，若知道，根据自己需求变更）：
<ol>
<li>以<code>default-features = false</code>出现的，一定要指定为<code>xxx/std</code></li>
<li>以<code>optional = true</code>出现的，一定指代为当前包名</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>需要注意的点：</p>
<p><strong>由于cargo.toml 对编写出错没有显著提示</strong>，因此若出现不明原因错误，检查cargo.toml时一定要注意以下几点：</p>
<ol>
<li><code>default-features</code>的<code>feature</code>是带<code>s</code>的</li>
<li>若填写的<code>default-features=false</code>，那么在<code>std</code>指定的列表里必须要留意有没有也添加了<code>/std</code>，一定不能忘记在<code>std</code>中也出现对应的包，否则如果遗漏，编译到wasm时，可能会有奇怪的错误。</li>
<li><code>[dev-dependencies]</code>是用于test的，因此直接正常引入即可</li>
</ol>
<p>总体来说一定要保证<code>dependencies</code>和<code>features</code>没有编写出错</p>
<h3 id="2-runtime依赖树中的crate项目内容的编写"><a class="header" href="#2-runtime依赖树中的crate项目内容的编写">2. Runtime依赖树中的crate项目内容的编写</a></h3>
<p>对于这个crate项目，需要注意的有以下几点：</p>
<ol>
<li>lib.rs文件中的第一行<strong>必须有</strong><code>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]</code></li>
<li>引入标准库的类型，如<code>Vec</code>, <code>Result</code>，<code>BTreeMap</code>等等，必须通过<code>sp-std</code>这个库引入。</li>
<li>在Runtime的依赖库中，不能出现没有在<code>sp-std</code>导入的原本std拥有的标准库类型及宏，例如<code>String</code>，宏<code>println!</code>，若一定要出现，那么需要通过条件编译<code>#[cfg(feature = &quot;std&quot;)]</code>包起来，那么被条件编译包起来的部分，显然在编译wasm的时候不会被编译进去，<strong>那么就必须得保证即使wasm没有编译这部分逻辑，那么native与wasm的执行结果也必须保持一致</strong> （例如只有println在里面的话，只会产生的在native下打印的效果，不会影响执行的结果。但是若是有操作逻辑改变了变量状态在条件编译中，那么是一定要禁止的，否则就会导致节点运行过程中产生不同的结果）</li>
</ol>
<p>举例：</p>
<p>我们来观察Substrate的frame提供的包<code>frame/assets</code>，我们修改assets下的内容，然后<strong>在substrate根目录下执行<code>cargo build</code>进行编译</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]  // 第一行即出现这个条件编译控制语句
<span class="boring">fn main() {
</span>// 接下来若编写
// use std::vec::Vec;  // 在wasm下编译不通过
use sp_std::vec::Vec; // 编译通过
// use std::string::String; // 在wasm下编译不通过

decl_module! {
	pub struct Module&lt;T: Trait&gt; for enum Call where origin: T::Origin {
		type Error = Error&lt;T&gt;;
        fn issue(origin, #[compact] total: T::Balance) {
			let origin = ensure_signed(origin)?;
			// println(&quot;test&quot;); // wasm下编译不通过
            #[cfg(feature = &quot;std&quot;)] {
                println(&quot;test&quot;); // 能编译通过，但是在wasm执行中不会打印出来，只有在native执行中才会打印
            }
			//...
		}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>其他情况下例如需要出现能支持serde序列化的结构体，这里列举一个例子<code>substrate/frame/evm/src/lib.rs:L36</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Eq, PartialEq, Encode, Decode, Default)]
#[cfg_attr(feature = &quot;std&quot;, derive(Debug, Serialize, Deserialize))]  // 请注意这里支持serde序列化的部分是在 `std` 条件编译下的
/// External input from the transaction.
pub struct Vicinity {
	/// Current transaction gas price.
	pub gas_price: U256,
	/// Origin of the transaction.
	pub origin: H160,
}
<span class="boring">}
</span></code></pre></pre>
<p>对于结构体，尤其需要留意<code>Debug</code>的trait，这里在<code>#[derive()]</code>自动推导的地方，只能使用<code>RuntimeDebug</code>而不能使用std下的<code>Debug</code>，例如balances模块下的例子<code>frame/balances/src/lib.rs:L310</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Struct to encode the vesting schedule of an individual account.
#[derive(Encode, Decode, Copy, Clone, PartialEq, Eq, RuntimeDebug)]
pub struct VestingSchedule&lt;Balance, BlockNumber&gt; {
	/// Locked amount at genesis.
	pub locked: Balance,
	/// Amount that gets unlocked every block after `starting_block`.
	pub per_block: Balance,
	/// Starting block for unlocking(vesting).
	pub starting_block: BlockNumber,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="3-引入一个第三方库兼容runtime-wasm的编译环境"><a class="header" href="#3-引入一个第三方库兼容runtime-wasm的编译环境">3. 引入一个第三方库兼容Runtime wasm的编译环境</a></h3>
<p>对于以上自己编写Runtime引用到的crate时，若不明白原理，还可以直接照抄即可。但是要引入第三方库的时候就比较麻烦了，需要比较深入了解后可能才知道怎么引入编译。</p>
<p>由于上文提到的关于wasm的标准库的导入问题，因此<strong>可能会出现一个第三方包虽然在自己描述中介绍了支持Rust wasm编译，但是不一定支持Runtime wasm的编译。</strong></p>
<p>那么这里先说明一个原则：</p>
<p><strong>请分清引入这个库的作用，确保这份代码的执行必须在Runtime内部，若确定只能在Runtime内部，那么只能尝试将其改成能满足前面说的条件的情况，并且其一系列依赖也要满足条件，若不确定只在Runtime内部运行，那么只把定义抽离出来，将实现通过<code>runtime_interface</code>导出到native执行</strong></p>
<p>若这个库只需要在native下执行（如serde），那么使用Optional引入，只在std下编译。</p>
<p>因此若一个第三方库一定要引入Runtime的编译依赖中，<strong>请再三思量是否是必须要引入</strong>的，因为这并非一件简单的事情。一方面引入新的库，编译会造成wasm文件庞大（因为会引入很多依赖一同编译），一方面将一个库改造成能在Runtime wasm下编译需要很多工作量。</p>
<p>因此例如：</p>
<ol>
<li>
<p>若只是需要一些小的工具函数，那么直接拷贝进入runtime为妙。</p>
</li>
<li>
<p>若是<strong>需要一些密码库</strong>，那么请参考Substrate实现ed25519，escda等密码学函数的方法，抽离定义，将实现通过<code>runtime_interface</code>放在native下实现。这块内容在进阶部分笔者再进行讲解</p>
</li>
</ol>
<h2 id="总结-7"><a class="header" href="#总结-7">总结</a></h2>
<p>本文简要介绍了Substrate 的Runtime wasm的实现要点，指明Runtime的wasm实际上是rust wasm的一个子集，其使用过程中受到Runtime WASM的限制。因此在编写自己的crate进入Runtime依赖树中时，请按照本文指明的方式进行编写。若采用第三方库引入时，请再三权衡，并根据情况做出判定。<strong>否则可能会在解决如何编译的过程中花费大量时间。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---runtime的构成--十"><a class="header" href="#substrate-入门---runtime的构成--十">Substrate 入门 - Runtime的构成 -（十）</a></h1>
<p>由于疫情原因，以及近期在忙于其他开发，因此文章停滞了一段时间。之前的文章已经介绍了Runtime的概要以及Runtime的wasm，因此读者应该具备了对Runtime的全局观念以及如何通过编译过程的基本知识。因此从本文开始，将会进入对Runtime的正式介绍。</p>
<p>本文首先介绍Substrate的Runtime的构成。</p>
<h2 id="一个完整的substrate-runtime"><a class="header" href="#一个完整的substrate-runtime">一个完整的Substrate Runtime</a></h2>
<p>对于一个完成的Runtime，其主要实现位于：<code>bin/node/runtime/src/lib.rs</code>中。</p>
<p>一个Runtime一定需要含有如下组件：</p>
<p><img src="imgs/s10_1.jpg" alt="" /></p>
<ol>
<li>RuntimeVersion：用于标示当前Runtime的版本，是用于区分执行wasm和native的重要属性。每次若出现逻辑变更<strong>都应该</strong>手动修改这个版本号（其中分影响共识结果和不影响共识结果的版本）。若出现了影响共识结果的改动但不修改这个版本号，并仍然部署了修改后的wasm，可能会造成无法出块或者无法同步等严重后果。</li>
<li>Runtime的模块实现<code>construct_runtime!</code>：构建Runtime所有模块的宏。在编写了一个Runtime的模块后，必须通过这个宏引入构建。在这个宏里会生成很多其他的附属信息如该模块的结构体，对应的一些trait的实现，metadata，等等。
<ol>
<li>在<code>lib.rs</code>中的trait的关联属性以及api的调用中可以看到类似<code>type Currency = Balances;</code>，<code>type Time = Timestamp;</code>等的定义，这个关联属性右边的类型就是通过这个宏展开得到。</li>
<li>这个宏的构建中，控制了每个模块会导出一些属性如<code>Storage</code>，<code>Call</code>，<code>Event</code>，<code>Config</code>等等</li>
<li>在这个宏中<code>System</code>是特殊的，一定要引入。</li>
<li>除了对应每个模块生成对应的类型以外，这个宏还会生成一些统一的类型和信息如<code>Runtime</code>这个结构体，<code>AllModules</code>，<code>Call</code>等等。</li>
</ol>
</li>
<li>Runtime中与链相关的一些类型定义：如区块，交易体，区块头等等。有一些定义要参与到<code>construct_runtime!</code>宏中的构建，有一些定义需要对外暴露提供调用。Substrate的抽象很好，基本上所有链的基本元素定义都是可以自由定制的。例如签名可以替换成单个签名或允许多种类型秘钥的签名，地址可以替换成使用accountid或兼容几种查询等等。</li>
<li>Runtime的执行器：执行器虽然也是一个Runtime模块，但其是特殊的，甚至比System模块还特殊。执行器不参与<code>construct_runtime!</code>宏的构建，而是直接定义。其提供了Runtime正常运行的所有接口，如初始化，执行区块，执行交易，验证交易等等。执行器需要依托<code>construct_runtime!</code>宏导出的<code>AllModules</code>，也就是说执行器持有所有模块的类型，将会控制这些模块的<code>OnInitialize</code>，<code>OnFinalize</code>等等。</li>
<li>Runtime的Api实现<code>impl_runtime_apis!</code>：前面的文章介绍过Runtime与外界交互的接口，这个宏即是所有api的实现部分。对于api首先先有定义api的宏<code>decl_runtime_apis!</code>，然后对应于这个定义的api，可以在<code>impl_runtime_apis!</code>中有对应的实现。Substrate默认提供了一些api的定义，其中<code>Core</code>的api定义是一定要实现的。其他的一些api如<code>BlockBuilder</code>，共识相关的api，虽然不是在<code>Core</code>里，但是为了让一个Runtime能以“链”的形式存在，也是一定要实现的，但是若作为平行链，那么例如和共识相关的这些api就不用存在了。</li>
</ol>
<p>总体来说，拥有以上5部分可构成一个完整的Substrate Runtime。</p>
<h2 id="runtime的模块构建"><a class="header" href="#runtime的模块构建">Runtime的模块构建</a></h2>
<p>通过以上介绍可知，一个Runtime的核心就是<code>construct_runtime!</code>，其起到了集合所有Runtime模块并产生对于类型的作用。是整个Runtime的总控制开关。也就是通过这个宏，可以插拔的控制Runtime模块的引入，也就是控制“链的功能”。</p>
<p><code>construct_runtime!</code>模块中每一行是一个模块，添加进入即代表构建当前Runtime的时候引入该模块。</p>
<p>一般而言，有一个模块是必不可少的：</p>
<ul>
<li>System：该模块用于描述链的一些基本属性，因此无论公链还是联盟链都必不可少。并且这个模块在<code>construct_runtime!</code>宏内也是被特殊处理的，必须位于第一个且不可缺少。在这个模块中需要参与块的初始化<code>on_initialize</code>，块的结束处理<code>on_finalize</code>，区块的块高，交易数量，父hash，交易根，事件Event等等一系列与链息息相关的数据定义都在这个模块里。可以说是类似“环境变量”这一概念在链中存在的地位。</li>
</ul>
<p>除此之外的所有模块都是可选的，但是这里的可选的意思并非对于一条链，而只是对于基本构建而言。对于一条链所需要的模块，笔者大概分为以下两类：</p>
<ul>
<li>满足链的业务逻辑</li>
<li>对Runtime外层一些功能的数据映射，或是提供数据让底层模块做出相应变更。</li>
</ul>
<p>例如：</p>
<p>满足链的业务逻辑：</p>
<ul>
<li><code>balances</code>模块，记录用户的资金变化，一般公链必须要有，联盟链根据需求裁定</li>
<li><code>staking</code>模块，pos公链必须，pow公链与联盟链反而不需要。</li>
<li><code>contracts</code>模块，合约模块，根据链业务逻辑觉得是否需要。</li>
<li><code>council</code>，<code>treasury</code>，<code>transactionpayment</code>等等，根据命名可以大概猜测其含义</li>
<li>等等</li>
</ul>
<p>对Runtime外层起效或交互的模块</p>
<ul>
<li><code>Babe</code>。使用babe共识必须，可以设置babe当前的出块人，底层babe共识模块会通过api读取当前的设置，当前的epoch 等等。例如一个epoch变化后，更换出块人列表，那么可以通过staking模块处理好对应的出块人列表然后设置进入babe的Runtime模块，然后在这轮出块中，底层的babe模块就可以读到最新的出块人列表。</li>
<li><code>Aura</code>。使用arua共识必须，和babe同理提供当前的出块人。</li>
<li><code>Grandpa</code>。提供grandpa验证人，同样可以在Runtime内通过其他逻辑变更影响底层grandpa逻辑进行确认</li>
<li><code>ImOnline</code>。底层通过内部交易/offchain等反馈当前节点存活情况，<strong>是一个获知外界信息（oracle）的很好例子</strong></li>
<li><code>FinalityTracker</code>。提供grandpa的finality已经到哪一个块的模块，是<strong>反馈底层模块信息的</strong>例子</li>
<li>等等</li>
</ul>
<p>而对于在<code>construct_runtime!</code>定义的每一行而言，类似：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>System: frame_system::{Module, Call, Config, Storage, Event&lt;T&gt;}
<span class="boring">}
</span></code></pre></pre>
<p>在宏的注释中有简略介绍：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// We provide support for the following module parts in a pallet:
///
/// - `Module`
/// - `Call`
/// - `Storage`
/// - `Event` or `Event&lt;T&gt;` (if the event is generic)
/// - `Origin` or `Origin&lt;T&gt;` (if the origin is generic)
/// - `Config` or `Config&lt;T&gt;` (if the config is generic)
/// - `Inherent ( $(CALL),* )` - If the module provides/can check inherents. The optional parameter
///                             is for modules that use a `Call` from a different module as
///                             inherent.
/// - `ValidateUnsigned`      - If the module validates unsigned extrinsics. 
<span class="boring">}
</span></code></pre></pre>
<p>这里稍微多做一些介绍：</p>
<p>这样的宏定义有一些类似rust中的<code>use module::{xxx, xxx}</code>，表示在通过<code>construct_runtime!</code>集成这个模块的时候需要导出这个模块的一些统一的功能。</p>
<ul>
<li>
<p><code>Module</code>，表示导出这个模块的结构体，其结构体名字对应于这行定义开头，例如例子中的<code>System</code>，是这个模块产生于Runtime中的模块名，通过这个宏将会生成<code>pub struct System</code>，这个结构体，在<code>lib.rs</code>中引用中出现在<code>type=</code>右边的，在api中出现类似<code>Contracts::</code>这样的，这个结构体的名字是由这里的<code>Module</code>指定。因此若这个名字更改，相应的地方也需要做更改。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>System: frame_system::{Module}
// Module 表示导出以这行开头的定义的结构体 System
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>Call</code>，表示导出这个模块可以对于的交易（Extrinsic）中的方法，例如<code>balances</code>中的<code>transfer</code>啊这类的。也就是<code>Call</code>是模块通过交易能够接受的接口调用。</p>
</li>
<li>
<p><code>Storage</code>，表示导出这个模块的存储。这里注意只要在模块内部定义了storage（后几篇文章会介绍），即使不导出这个存储这个存储也是存在的。这里是否导出更大的是影响metadata的生成。</p>
</li>
<li>
<p><code>Event</code>，表示导出这个模块的Event。对metadata影响大</p>
</li>
<li>
<p><code>Origin</code>，表示导出模块的Origin，对应于这个模块中定义了类似一下的origin定义</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Module&lt;T: Trait&lt;I&gt;, I: Instance=DefaultInstance&gt; for enum Call where origin: &lt;T as frame_system::Trait&gt;::Origin {
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><code>Config</code>，表示是否导出genesis的配置，这个Config会影响genesis的生成</p>
</li>
<li>
<p><code>Inherent</code>，导出内部交易。其用法参考 <code>Timestamp</code>，这是个很好的例子。</p>
</li>
<li>
<p><code>ValidateUnsigned</code>，这个更多的和offchain相关。</p>
</li>
</ul>
<p>以上即是对<code>construct_runtime!</code>粗略的介绍。</p>
<h2 id="总结-8"><a class="header" href="#总结-8">总结</a></h2>
<p>本文介绍了Runtime的构成元素。通过本文应知道，一个Runtime基本上由5个部分组成，其中<code>construct_runtime!</code>的构成是最核心与重要的。应该理解<code>construct_runtime!</code>是Runtime模块的总开关，控制了该Runtime的组合逻辑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="substrate-入门---学习runtime必备的技能--十一"><a class="header" href="#substrate-入门---学习runtime必备的技能--十一">Substrate 入门 - 学习Runtime必备的技能 -（十一）</a></h1>
<p>上一篇文章介绍了Runtime的构成方式。但是在介绍过程中我们可以看到，其比较核心的组件大多都是用rust的宏编写。熟悉编程语言的人应该知道，宏本质上是创建了一种DSL，使用者必须按创作者的方式来编写才可编译通过，因此宏更像是黑盒，在中间做了许多表面上看不到的事情。</p>
<p>Rust使用了卫生宏系统，在编译器可以安全的解决许多问题，而Substrate的开发者对于宏似乎有一些迷恋，在Runtime中诸多核心组件都采用了宏，并且通过宏自动化做了相当多的事情并生成了许多额外变量和类型。笔者个人觉得Substrate的框架在宏的使用上有一些滥用，其在一定程度上阻碍了使用者能够轻松理解Substrate的这套系统。但客观来说，Substrate Runtime中的宏做了许多重复性与自动化的工具，隐藏了许多细节不需要开发人员需要操心的细节，因此如果能<strong>正确理解了创作者创建这个宏所表达的意图</strong>，那么确实可以节省很多无用的工作。</p>
<p>所以关键问题在于如何理解这个宏背后所做的工作，因为只有正确理解了才能明白例如在上一篇文章中介绍的Module类型的生成等情况。</p>
<h2 id="展开宏"><a class="header" href="#展开宏">展开宏</a></h2>
<p>要理解宏背后做的工作，最直接的方式当然就是看宏自身是怎么写的。但是平心而论，Substrate编写这块的作者虽然有一些滥用宏，但是他的技巧是十分高超，生成宏这部分的代码量都十分庞大。若不是对宏系统十分熟悉（因为如果只是写简单的宏理解起来不困难，但是若不常写，只是看宏的话那些<code>$</code>替换符会很别扭，思维也不容易把这些联系起来），那么硬生生去读宏的写法会相当困难。</p>
<p>因此若只是为了理解宏最后干了什么事情的话，使用宏展开比去理解宏的写法好得多。</p>
<p>因此本文介绍在Runtime中宏展开及一些相应技巧。</p>
<p>首先先要明确一个前提，由于之前的介绍，我们应该能理解对于Runtime而言，native和wasm应该在大部分情况下是同一份代码。因此我们展开宏一般情况下只针对native展开。很特殊及稀少的情况下才可能需要wasm展开。那么在展开wasm的时候请依据之前的文章添加上相应的feature开关。</p>
<p>展开宏笔者在这里介绍是对于<code>crate</code>维度，不针对<code>xxx.rs</code>维度。因为只编译<code>xxx.rs</code>难度很大，而且在很多情况下反而不太方便。</p>
<p>例如如果想要node项目中的runtime的宏，那么首先切换到相应的<code>crate</code>目录下：</p>
<pre><code class="language-bash">cd bin/node/runtime/
</code></pre>
<p>然后使用<code>carge</code>的宏展开命令：</p>
<pre><code class="language-bash">cargo rustc -- -Z unstable-options --pretty=expanded &gt; runtime.rs
</code></pre>
<p>由于目前Substrate已经支持stable的rust了，所以这里展开没必要用nightly。如果需要nightly，那么在<code>cargo</code>后面加上<code>+nightly</code></p>
<p>另一方面，由于当前runtime的特性，我们首先要看到在<code>bin/node/runtime/src/lib.rs:L74</code>行，有：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make the WASM binary available.
#[cfg(feature = &quot;std&quot;)]
include!(concat!(env!(&quot;OUT_DIR&quot;), &quot;/wasm_binary.rs&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>因此这里需要明白在<code>bin/node/runtime/</code>展开宏的时候，事实上把编译好的wasm代码也包含了进来。而对于当前的substrate来说，wasm即使在release模式下也已经达到了1.7M（见文件<code>target/debug/wbuild/node-runtime/node_runtime.compact.wasm</code>），若wasm以debug编译有10几兆大小。因此在上面<code>cargo rustc</code>中将输出重定向到的<code>runtime.rs</code>一定大于这数。</p>
<pre><code class="language-bash">$-&gt; ll -h
-rw-r--r-- 1 name name  955 2月  26 11:08 build.rs
-rw-r--r-- 1 name name 7.7K 3月   1 10:14 Cargo.toml
-rw-r--r-- 1 name name  11M 3月   1 20:32 runtime.rs
drwxr-xr-x 2 name name 4.0K 1月  13 20:49 src
</code></pre>
<p>此时若使用ide的读者，不要急着直接点开这个文件，而且先经过以下操作再打开。</p>
<p>由于wasm被包含进入了<code>runtime.rs</code>，而实际上我们并不需要看懂编译出来的wasm的字节串，因此我们将其直接删除即可：</p>
<pre><code class="language-bash">vim runtime.rs
</code></pre>
<p>打开后搜索<code>WASM_BINARY</code>，找到后删除这一行及下一行字节乱码串(就是编译的wasm)</p>
<p>再搜索<code>WASM_BINARY_BLOATY</code>，同样删除这一行及下一行</p>
<p>然后保存退出</p>
<pre><code class="language-bash">$-&gt; ll -h
-rw-r--r-- 1 name name  955 2月  26 11:08 build.rs
-rw-r--r-- 1 name name 7.7K 3月   1 10:14 Cargo.toml
-rw-r--r-- 1 name name  836k 3月   1 20:32 runtime.rs  # 请注意runtime.rs的体积已经缩小了很多
drwxr-xr-x 2 name name 4.0K 1月  13 20:49 src
</code></pre>
<p>此时再打开runtime.rs文件就不会受到wasm的干扰了，之后可以格式化一下，这样查看会好一些。</p>
<h2 id="展开后的runtimers"><a class="header" href="#展开后的runtimers">展开后的<code>runtime.rs</code></a></h2>
<p>我们通过以上方式可以得到这个展开的文件，那么我们可以查看一下上一章节提到的一些类型：</p>
<p>例如<code>AllModules</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type AllModules
=
((Vesting,
  (Recovery,
   (Society,
    (Identity,
     (RandomnessCollectiveFlip,
      (Offences,
       (AuthorityDiscovery,
        (ImOnline,
         (Sudo,
          (Contracts,
           (Treasury,
            (Grandpa,
             (FinalityTracker,
              (TechnicalMembership,
               (Elections,
                (TechnicalCommittee,
                 (Council,
                  (Democracy,
                   (Session,
                    (Staking,
                     (TransactionPayment,
                      (Balances,
                       (Indices,
                        (Authorship,
                         (Timestamp,
                          (Babe, (Utility, ))))))))))))))))))))))))))));
<span class="boring">}
</span></code></pre></pre>
<p>我们可以看到<code>AllModule</code>实际上是一个将所有模块集合在一起的嵌套元组，对应<code>OnInitialize</code>的定义<code>primitives/runtime/src/traits.rs:L343</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[impl_for_tuples(30)]  // 注意这个impl_for_tuples
pub trait OnInitialize&lt;BlockNumber&gt; {
	/// The block is being initialized. Implement to have something happen.
	fn on_initialize(_n: BlockNumber) {}
}
<span class="boring">}
</span></code></pre></pre>
<p>再跟随一下执行器对于<code>on_initialize</code>的实现<code>frame/executive/src/lib.rs:L186</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;AllModules as OnInitialize&lt;System::BlockNumber&gt;&gt;::on_initialize(*block_number);
<span class="boring">}
</span></code></pre></pre>
<p>即可<strong>理解<code>AllModules</code>为什么是使用嵌套元素的形式定义，而<code>on_initialize</code>的调用顺序即是<code>construct_runtime!</code>中模块定义的顺序</strong></p>
<p>例如<code>Runtime</code></p>
<p>我们在原本的<code>bin/node/runtime/lib.rs</code>中可以看到，每个runtime module导出的trait都实现给了<code>Runtime</code>类型，但是我们却不知道<code>Runtime</code>在哪定义了。</p>
<p>那么在展开文件中，我们可以搜索到</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Runtime;
<span class="boring">}
</span></code></pre></pre>
<p>因此，<code>Runtime</code>这个类型是由宏展开生成的，并且结合<code>lib.rs</code>，应该知道实际上所有的runtime module 中定义的trait都实现给了这个<code>Runtime</code>，因此这个<code>Runtime</code>是所有module的trait的实现体。而<code>Runtime</code>自身不持有任何成员，因此实际上持有Runtime的意义在于将所有module的trait中的关联属性集合到一个对象上。</p>
<p>例如<code>Balances</code></p>
<p>可以看到<code>Balances</code>的定义为：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type Balances = pallet_balances::Module&lt;Runtime&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>因此<code>Balances</code>结构体即是在<code>pallet_balances</code>这个crate下的Module，传入了Runtime的类型，而Runtime是所有trait的实现体。而我们在<code>frame/balances</code>这个crate下却不能发现<code>Module</code>的定义，而是在函数中会出现<code>&lt;Module&lt;T&gt;&gt;::xxx</code>这样的调用。因此我们可以知道两个实事：</p>
<ol>
<li>Module也是通过宏生成的，那么为了知道Module是啥，可以参照生成<code>runtime.rs</code>的方式去在<code>balances</code>这个<code>crate</code>下展开宏。</li>
<li>在最后的编译结果中，每个模块中的<code>&lt;Module&lt;T&gt;&gt;</code>里的<code>&lt;T&gt;</code>即是在runtime中生成的<code>Runtime</code>。</li>
</ol>
<p>其他类型同理。</p>
<h2 id="总结-9"><a class="header" href="#总结-9">总结</a></h2>
<p>从以上介绍可得，只要展开了宏，我们便可以看到宏后的世界，可以发现Substrate实际上帮开发者做了相当多的事情。因此若想要理解Substrate的Runtime，展开宏是必不可少的技能。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
